# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_wt5001', [dirname(__file__)])
        except ImportError:
            import _pyupm_wt5001
            return _pyupm_wt5001
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_wt5001', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_wt5001 = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_wt5001
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class uint8Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint8Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint8Array, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pyupm_wt5001.new_uint8Array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_wt5001.delete_uint8Array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _pyupm_wt5001.uint8Array___getitem__(self, *args)
    def __setitem__(self, *args): return _pyupm_wt5001.uint8Array___setitem__(self, *args)
    def cast(self): return _pyupm_wt5001.uint8Array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _pyupm_wt5001.uint8Array_frompointer
    if _newclass:frompointer = staticmethod(_pyupm_wt5001.uint8Array_frompointer)
uint8Array_swigregister = _pyupm_wt5001.uint8Array_swigregister
uint8Array_swigregister(uint8Array)

def uint8Array_frompointer(*args):
  return _pyupm_wt5001.uint8Array_frompointer(*args)
uint8Array_frompointer = _pyupm_wt5001.uint8Array_frompointer

class uint16Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint16Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint16Array, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pyupm_wt5001.new_uint16Array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_wt5001.delete_uint16Array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _pyupm_wt5001.uint16Array___getitem__(self, *args)
    def __setitem__(self, *args): return _pyupm_wt5001.uint16Array___setitem__(self, *args)
    def cast(self): return _pyupm_wt5001.uint16Array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _pyupm_wt5001.uint16Array_frompointer
    if _newclass:frompointer = staticmethod(_pyupm_wt5001.uint16Array_frompointer)
uint16Array_swigregister = _pyupm_wt5001.uint16Array_swigregister
uint16Array_swigregister(uint16Array)

def uint16Array_frompointer(*args):
  return _pyupm_wt5001.uint16Array_frompointer(*args)
uint16Array_frompointer = _pyupm_wt5001.uint16Array_frompointer

class WT5001(_object):
    """
    API for the WT5001 Serial MP3 Module.

    ID: wt5001

    Name: WT5001 Serial MP3 Module

    Other Names: Grove Serial MP3 Player

    Category: sound

    Manufacturer: seeed

    Link:http://www.seeedstudio.com/wiki/Grove_%E2%80%93_Serial_MP3_Player

    Connection: uart  UPM support for the WT5001 Serial MP3 module. This
    was tested specifically with the Grove Serial MP3 module.

    C++ includes: wt5001.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WT5001, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WT5001, name)
    __repr__ = _swig_repr
    NONE = _pyupm_wt5001.WT5001_NONE
    PLAY_SD = _pyupm_wt5001.WT5001_PLAY_SD
    PLAY_SPI = _pyupm_wt5001.WT5001_PLAY_SPI
    PLAY_UDISK = _pyupm_wt5001.WT5001_PLAY_UDISK
    PAUSE = _pyupm_wt5001.WT5001_PAUSE
    STOP = _pyupm_wt5001.WT5001_STOP
    NEXT = _pyupm_wt5001.WT5001_NEXT
    PREVIOUS = _pyupm_wt5001.WT5001_PREVIOUS
    SET_VOLUME = _pyupm_wt5001.WT5001_SET_VOLUME
    QUEUE = _pyupm_wt5001.WT5001_QUEUE
    PLAY_MODE = _pyupm_wt5001.WT5001_PLAY_MODE
    COPY_SD2FLASH = _pyupm_wt5001.WT5001_COPY_SD2FLASH
    COPY_UDISK2FLASH = _pyupm_wt5001.WT5001_COPY_UDISK2FLASH
    INSERT_SONG = _pyupm_wt5001.WT5001_INSERT_SONG
    SET_DATE = _pyupm_wt5001.WT5001_SET_DATE
    SET_TIME = _pyupm_wt5001.WT5001_SET_TIME
    SET_ALARM = _pyupm_wt5001.WT5001_SET_ALARM
    SET_ALARM_DUR = _pyupm_wt5001.WT5001_SET_ALARM_DUR
    CLEAR_ALARM = _pyupm_wt5001.WT5001_CLEAR_ALARM
    CLEAR_ALARM_DUR = _pyupm_wt5001.WT5001_CLEAR_ALARM_DUR
    READ_VOLUME = _pyupm_wt5001.WT5001_READ_VOLUME
    READ_PLAY_STATE = _pyupm_wt5001.WT5001_READ_PLAY_STATE
    READ_SPI_NUMF = _pyupm_wt5001.WT5001_READ_SPI_NUMF
    READ_SD_NUMF = _pyupm_wt5001.WT5001_READ_SD_NUMF
    READ_UDISK_NUMF = _pyupm_wt5001.WT5001_READ_UDISK_NUMF
    READ_CUR_FNAME = _pyupm_wt5001.WT5001_READ_CUR_FNAME
    READ_CF_CHAR = _pyupm_wt5001.WT5001_READ_CF_CHAR
    READ_DATE = _pyupm_wt5001.WT5001_READ_DATE
    READ_TIME = _pyupm_wt5001.WT5001_READ_TIME
    NORMAL = _pyupm_wt5001.WT5001_NORMAL
    SINGLE_REPEAT = _pyupm_wt5001.WT5001_SINGLE_REPEAT
    ALL_REPEAT = _pyupm_wt5001.WT5001_ALL_REPEAT
    RANDOM = _pyupm_wt5001.WT5001_RANDOM
    SD = _pyupm_wt5001.WT5001_SD
    SPI = _pyupm_wt5001.WT5001_SPI
    UDISK = _pyupm_wt5001.WT5001_UDISK
    def __init__(self, *args): 
        """
        __init__(upm::WT5001 self, int uart) -> WT5001

        Parameters:
            uart: int


        WT5001(int uart)

        WT5001 constructor

        Parameters:
        -----------

        uart:  Default UART to use (0 or 1) 
        """
        this = _pyupm_wt5001.new_WT5001(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_wt5001.delete_WT5001
    __del__ = lambda self : None;
    def dataAvailable(self, *args):
        """
        dataAvailable(WT5001 self, unsigned int millis) -> bool

        Parameters:
            millis: unsigned int


        bool
        dataAvailable(unsigned int millis)

        Checks to see if there is data available for reading

        Parameters:
        -----------

        millis:  Number of milliseconds to wait; 0 means no waiting

        True if there is data available for reading 
        """
        return _pyupm_wt5001.WT5001_dataAvailable(self, *args)

    def readData(self, *args):
        """
        readData(WT5001 self, char * buffer, int len) -> int

        Parameters:
            buffer: char *
            len: int


        int readData(char
        *buffer, int len)

        Reads any available data in a user-supplied buffer. Note: the call
        blocks until data is available to be read. Use dataAvailable() to
        determine whether there is data available beforehand, to avoid
        blocking.

        Parameters:
        -----------

        buffer:  Buffer to hold the data read

        len:  Length of the buffer

        Number of bytes read 
        """
        return _pyupm_wt5001.WT5001_readData(self, *args)

    def writeData(self, *args):
        """
        writeData(WT5001 self, char * buffer, int len) -> int

        Parameters:
            buffer: char *
            len: int


        int writeData(char
        *buffer, int len)

        Writes the data in the buffer to the device

        Parameters:
        -----------

        buffer:  Buffer to hold the data read

        len:  Length of the buffer

        Number of bytes written 
        """
        return _pyupm_wt5001.WT5001_writeData(self, *args)

    def setupTty(self, *args):
        """
        setupTty(WT5001 self, speed_t baud=B9600) -> bool

        Parameters:
            baud: speed_t

        setupTty(WT5001 self) -> bool

        Parameters:
            self: upm::WT5001 *


        bool setupTty(speed_t
        baud=B9600)

        Sets up proper tty I/O modes and the baud rate. The default baud rate
        is 9,600 (B9600).

        Parameters:
        -----------

        baud:  Desired baud rate.

        True if successful 
        """
        return _pyupm_wt5001.WT5001_setupTty(self, *args)

    def checkResponse(self, *args):
        """
        checkResponse(WT5001 self, upm::WT5001::WT5001_OPCODE_T opcode) -> bool

        Parameters:
            opcode: enum upm::WT5001::WT5001_OPCODE_T


        bool
        checkResponse(WT5001_OPCODE_T opcode)

        Gets a command response and returns its validity

        Parameters:
        -----------

        index:  Opcode to verify

        True if successful 
        """
        return _pyupm_wt5001.WT5001_checkResponse(self, *args)

    def play(self, *args):
        """
        play(WT5001 self, upm::WT5001::WT5001_PLAYSOURCE_T psrc, uint16_t index) -> bool

        Parameters:
            psrc: enum upm::WT5001::WT5001_PLAYSOURCE_T
            index: uint16_t


        bool
        play(WT5001_PLAYSOURCE_T psrc, uint16_t index)

        Plays a file from a source

        Parameters:
        -----------

        psrc:  Play source (SD, UDISK, SPI)

        index:  File number to play

        True if successful 
        """
        return _pyupm_wt5001.WT5001_play(self, *args)

    def stop(self):
        """
        stop(WT5001 self) -> bool

        Parameters:
            self: upm::WT5001 *


        bool stop()

        Stops playing

        True if successful 
        """
        return _pyupm_wt5001.WT5001_stop(self)

    def pause(self):
        """
        pause(WT5001 self) -> bool

        Parameters:
            self: upm::WT5001 *


        bool pause()

        Pauses the playback or resumes it if already paused

        True if successful 
        """
        return _pyupm_wt5001.WT5001_pause(self)

    def next(self):
        """
        next(WT5001 self) -> bool

        Parameters:
            self: upm::WT5001 *


        bool next()

        Moves to the next track

        True if successful 
        """
        return _pyupm_wt5001.WT5001_next(self)

    def previous(self):
        """
        previous(WT5001 self) -> bool

        Parameters:
            self: upm::WT5001 *


        bool previous()

        Moves to the previous track

        True if successful 
        """
        return _pyupm_wt5001.WT5001_previous(self)

    def setVolume(self, *args):
        """
        setVolume(WT5001 self, uint8_t vol) -> bool

        Parameters:
            vol: uint8_t


        bool setVolume(uint8_t
        vol)

        Sets the volume. Valid range is 0-31. 0 means mute.

        True if successful 
        """
        return _pyupm_wt5001.WT5001_setVolume(self, *args)

    def queue(self, *args):
        """
        queue(WT5001 self, uint16_t index) -> bool

        Parameters:
            index: uint16_t


        bool queue(uint16_t index)

        Queues a track to play next, when the current song is finished

        Parameters:
        -----------

        index:  File number to queue

        True if successful 
        """
        return _pyupm_wt5001.WT5001_queue(self, *args)

    def setPlayMode(self, *args):
        """
        setPlayMode(WT5001 self, upm::WT5001::WT5001_PLAYMODE_T pm) -> bool

        Parameters:
            pm: enum upm::WT5001::WT5001_PLAYMODE_T


        bool
        setPlayMode(WT5001_PLAYMODE_T pm)

        Sets the playback mode

        Parameters:
        -----------

        pm:  Play mode to enable

        True if successful 
        """
        return _pyupm_wt5001.WT5001_setPlayMode(self, *args)

    def insert(self, *args):
        """
        insert(WT5001 self, uint16_t index) -> bool

        Parameters:
            index: uint16_t


        bool insert(uint16_t
        index)

        Inserts a track to play immediately, interrupting the current track.
        When the inserted track is finished, the interrupted track resumes
        where it was interrupted.

        Parameters:
        -----------

        index:  File number to insert

        True if successful 
        """
        return _pyupm_wt5001.WT5001_insert(self, *args)

    def setDate(self, *args):
        """
        setDate(WT5001 self, uint16_t year, uint8_t month, uint8_t day) -> bool

        Parameters:
            year: uint16_t
            month: uint8_t
            day: uint8_t


        bool setDate(uint16_t
        year, uint8_t month, uint8_t day)

        Sets the date of the internal clock

        Parameters:
        -----------

        year:  4-digit year

        month:  Month

        day:  Day

        True if successful 
        """
        return _pyupm_wt5001.WT5001_setDate(self, *args)

    def setTime(self, *args):
        """
        setTime(WT5001 self, uint8_t hour, uint8_t minute, uint8_t second) -> bool

        Parameters:
            hour: uint8_t
            minute: uint8_t
            second: uint8_t


        bool setTime(uint8_t
        hour, uint8_t minute, uint8_t second)

        Sets the time of the internal clock

        Parameters:
        -----------

        hour:  Hour

        minute:  Minute

        second:  Second

        True if successful 
        """
        return _pyupm_wt5001.WT5001_setTime(self, *args)

    def setAlarm(self, *args):
        """
        setAlarm(WT5001 self, uint8_t hour, uint8_t minute, uint8_t second) -> bool

        Parameters:
            hour: uint8_t
            minute: uint8_t
            second: uint8_t


        bool setAlarm(uint8_t
        hour, uint8_t minute, uint8_t second)

        Sets the alarm

        Parameters:
        -----------

        hour:  Hour

        minute:  Minute

        second:  Second

        True if successful 
        """
        return _pyupm_wt5001.WT5001_setAlarm(self, *args)

    def clearAlarm(self):
        """
        clearAlarm(WT5001 self) -> bool

        Parameters:
            self: upm::WT5001 *


        bool clearAlarm()

        Clears any alarm that has been set

        True if successful 
        """
        return _pyupm_wt5001.WT5001_clearAlarm(self)

    def getVolume(self, *args):
        """
        getVolume(WT5001 self, uint8_t * vol) -> bool

        Parameters:
            vol: uint8_t *


        uint8_t getVolume()

        Gets the current volume

        Volume

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_wt5001.WT5001_getVolume(self, *args)

    def getVolumeNoParam(self):
        """
        getVolumeNoParam(WT5001 self) -> uint8_t

        Parameters:
            self: upm::WT5001 *


        uint8_t getVolume()

        Gets the current volume

        Volume

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_wt5001.WT5001_getVolumeNoParam(self)

    def getPlayState(self, *args):
        """
        getPlayState(WT5001 self, uint8_t * ps) -> bool

        Parameters:
            ps: uint8_t *


        uint8_t
        getPlayState()

        Gets the current play state: 1 = playing, 2 = stopped, 3 = paused

        Play state

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_wt5001.WT5001_getPlayState(self, *args)

    def getPlayStateNoParam(self):
        """
        getPlayStateNoParam(WT5001 self) -> uint8_t

        Parameters:
            self: upm::WT5001 *


        uint8_t
        getPlayState()

        Gets the current play state: 1 = playing, 2 = stopped, 3 = paused

        Play state

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_wt5001.WT5001_getPlayStateNoParam(self)

    def getNumFiles(self, *args):
        """
        getNumFiles(WT5001 self, upm::WT5001::WT5001_PLAYSOURCE_T psrc, uint16_t * numf) -> bool

        Parameters:
            psrc: enum upm::WT5001::WT5001_PLAYSOURCE_T
            numf: uint16_t *


        uint16_t
        getNumFiles(WT5001_PLAYSOURCE_T psrc)

        Gets the number of files present on the source device

        Parameters:
        -----------

        psrc:  Storage source

        Number of files

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_wt5001.WT5001_getNumFiles(self, *args)

    def getNumFilesOneParam(self, *args):
        """
        getNumFilesOneParam(WT5001 self, upm::WT5001::WT5001_PLAYSOURCE_T psrc) -> uint16_t

        Parameters:
            psrc: enum upm::WT5001::WT5001_PLAYSOURCE_T


        uint16_t
        getNumFiles(WT5001_PLAYSOURCE_T psrc)

        Gets the number of files present on the source device

        Parameters:
        -----------

        psrc:  Storage source

        Number of files

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_wt5001.WT5001_getNumFilesOneParam(self, *args)

    def getCurrentFile(self, *args):
        """
        getCurrentFile(WT5001 self, uint16_t * curf) -> bool

        Parameters:
            curf: uint16_t *


        uint16_t
        getCurrentFile()

        Gets the index of the current file

        Index of the curretn file

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_wt5001.WT5001_getCurrentFile(self, *args)

    def getCurrentFileNoParam(self):
        """
        getCurrentFileNoParam(WT5001 self) -> uint16_t

        Parameters:
            self: upm::WT5001 *


        uint16_t
        getCurrentFile()

        Gets the index of the current file

        Index of the curretn file

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_wt5001.WT5001_getCurrentFileNoParam(self)

    def getDate(self, *args):
        """
        getDate(WT5001 self, uint16_t * year, uint8_t * month, uint8_t * day) -> bool

        Parameters:
            year: uint16_t *
            month: uint8_t *
            day: uint8_t *


        bool getDate(uint16_t
        *year, uint8_t *month, uint8_t *day)

        Gets the device date

        Parameters:
        -----------

        year:  4-digit year

        month:  Month

        day:  Day

        True if successful 
        """
        return _pyupm_wt5001.WT5001_getDate(self, *args)

    def getTime(self, *args):
        """
        getTime(WT5001 self, uint8_t * hour, uint8_t * minute, uint8_t * second) -> bool

        Parameters:
            hour: uint8_t *
            minute: uint8_t *
            second: uint8_t *


        bool getTime(uint8_t
        *hour, uint8_t *minute, uint8_t *second)

        Gets the device time

        Parameters:
        -----------

        hour:  Hour

        minute:  Minute

        second:  Second

        True if successful 
        """
        return _pyupm_wt5001.WT5001_getTime(self, *args)

WT5001_swigregister = _pyupm_wt5001.WT5001_swigregister
WT5001_swigregister(WT5001)
cvar = _pyupm_wt5001.cvar
WT5001_DEFAULT_UART = cvar.WT5001_DEFAULT_UART
WT5001_MAX_VOLUME = cvar.WT5001_MAX_VOLUME
WT5001_START = cvar.WT5001_START
WT5001_END = cvar.WT5001_END

# This file is compatible with both classic and new-style classes.


