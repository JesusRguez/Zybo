# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_nlgpio16', [dirname(__file__)])
        except ImportError:
            import _pyupm_nlgpio16
            return _pyupm_nlgpio16
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_nlgpio16', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_nlgpio16 = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_nlgpio16
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


NLGPIO16_DEFAULT_UART_DEV = _pyupm_nlgpio16.NLGPIO16_DEFAULT_UART_DEV
ADC_AREF = _pyupm_nlgpio16.ADC_AREF
ADC_PRECISION = _pyupm_nlgpio16.ADC_PRECISION
class NLGPIO16(_object):
    """
    API for the NLGPIO16 16 channel USB GPIO Module.

    ID: nlgpio16

    Name: NLGPIO16 16 channel USB GPIO Module

    Category: other

    Manufacturer: numatolabs

    Connection: uart

    Link:http://numato.com/16-channel-usb-gpio-module-with-analog-inputs/
    The NLGPIO16 is a USB adapter providing access to 16 GPIO's, 7 of
    which can be used as analog inputs. The GPIO's are 3.3v only. An
    external power supply can be connected to provide more current if the
    need arises.

    It is recommended to use a series resistor with the GPIO/ADC pins when
    interfacing with other circuits. In output mode, GPIOs can source up
    to 8mA (gpio8-gpio15). So no additional circuitry is needed to drive
    regular LEDs. A 470 Ohms series resistor is recommended for current
    limiting when connecting an LED to a GPIO. In contrast to GPIOs,
    analog inputs can read voltages at any level between 0 to 3.3V volts.
    It is recommended to use a series resistor to protect the input from
    stray voltages and spikes. The internal Analog to Digital converter
    supports 10 bits resolution which is adequate for most applications.

    Maximum IO source/sink current on GPIO 0-7 is 2mA Maximum IO
    source/sink current on GPIO 8-15 is 8mA

    C++ includes: nlgpio16.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NLGPIO16, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NLGPIO16, name)
    __repr__ = _swig_repr
    def __init__(self, uart="/dev/ttyACM0"): 
        """
        __init__(upm::NLGPIO16 self, std::string uart="/dev/ttyACM0") -> NLGPIO16

        Parameters:
            uart: std::string

        __init__(upm::NLGPIO16 self) -> NLGPIO16

        NLGPIO16(std::string
        uart=NLGPIO16_DEFAULT_UART_DEV)

        NLGPIO16 object constructor

        Parameters:
        -----------

        uart:  UART device path to use. Default is /dev/ttyACM0. 
        """
        this = _pyupm_nlgpio16.new_NLGPIO16(uart)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_nlgpio16.delete_NLGPIO16
    __del__ = lambda self : None;
    def getVersion(self):
        """
        getVersion(NLGPIO16 self) -> std::string

        Parameters:
            self: upm::NLGPIO16 *


        string getVersion()

        Get the version of the device

        String containing device revision 
        """
        return _pyupm_nlgpio16.NLGPIO16_getVersion(self)

    def getID(self):
        """
        getID(NLGPIO16 self) -> std::string

        Parameters:
            self: upm::NLGPIO16 *


        string getID()

        Get the device ID. The device ID is an 8 character alpha-numeric
        string.

        String containing device ID 
        """
        return _pyupm_nlgpio16.NLGPIO16_getID(self)

    def setID(self, *args):
        """
        setID(NLGPIO16 self, std::string id)

        Parameters:
            id: std::string


        void setID(std::string
        id)

        Set the device ID. The device ID is an 8 character alpha-numeric
        string. The supplied ID must be exactly 8 characters in length.

        Parameters:
        -----------

        id:  String containing a new 8 character device ID 
        """
        return _pyupm_nlgpio16.NLGPIO16_setID(self, *args)

    def gpioSet(self, *args):
        """
        gpioSet(NLGPIO16 self, int gpio)

        Parameters:
            gpio: int


        void gpioSet(int gpio)

        Set a gpio output to the HIGH (1) state. The gpio is automatically set
        as an output when this call is made, regardless of it's previous mode.

        Parameters:
        -----------

        gpio:  The gpio to set. Valid values are between 0-15 
        """
        return _pyupm_nlgpio16.NLGPIO16_gpioSet(self, *args)

    def gpioClear(self, *args):
        """
        gpioClear(NLGPIO16 self, int gpio)

        Parameters:
            gpio: int


        void gpioClear(int
        gpio)

        Set a gpio output to the LOW (0) state. The gpio is automatically set
        as an output when this call is made, regardless of it's previous mode.

        Parameters:
        -----------

        gpio:  The gpio to clear. Valid values are between 0-15 
        """
        return _pyupm_nlgpio16.NLGPIO16_gpioClear(self, *args)

    def gpioRead(self, *args):
        """
        gpioRead(NLGPIO16 self, int gpio) -> bool

        Parameters:
            gpio: int


        bool gpioRead(int
        gpio)

        Read the state of a gpio. The gpio is automatically set as an input
        when this call is made, regardless of it's previous mode.

        Parameters:
        -----------

        gpio:  The gpio to read. Valid values are between 0-15

        true if the gpio is in the HIGH state, false otherwise 
        """
        return _pyupm_nlgpio16.NLGPIO16_gpioRead(self, *args)

    def gpioReadAll(self):
        """
        gpioReadAll(NLGPIO16 self) -> unsigned int

        Parameters:
            self: upm::NLGPIO16 *


        unsigned int
        gpioReadAll()

        Read the state of all gpios. The returned integer is a bitmask of all
        16 gpios, where a 0 bit means the gpio is in the LOW state, whereas a
        1 bit means the gpio is in a HIGH state.

        bitmask of the state of all 16 gpios. The LSB is gpio0. 
        """
        return _pyupm_nlgpio16.NLGPIO16_gpioReadAll(self)

    def gpioSetIOMask(self, *args):
        """
        gpioSetIOMask(NLGPIO16 self, int mask)

        Parameters:
            mask: int


        void
        gpioSetIOMask(int mask)

        Set a mask for selectively updating multiple gpios with the
        gpioIODir() and gpioWriteAll() methods. Each bit set in the 16 bit
        argument (LSB = gpio0) represents whether the two previously mentioned
        methods will act on a given gpio or not. A 0 in a given bit position
        will cause any update to that gpio via gpioIODir() and gpioWriteAll()
        to be ignored, while a 1 bit enables that gpio to be affected by those
        two methods.

        Parameters:
        -----------

        mask:  A bitmask of the 16 gpios affected by gpioIODir() and
        gpioWriteAll() 
        """
        return _pyupm_nlgpio16.NLGPIO16_gpioSetIOMask(self, *args)

    def gpioSetIODir(self, *args):
        """
        gpioSetIODir(NLGPIO16 self, int mask)

        Parameters:
            mask: int


        void
        gpioSetIODir(int mask)

        Set the driection mode (input or output) for all gpios enabled by
        gpioSetIOMask(). A 0 in a given bit postion (LSB = gpio0) configures
        the gpio as an ouput, and a 1 bit configures the gpio as an input.
        Only the gpios enabled by gpioSetMask() are affected by this call.

        Parameters:
        -----------

        mask:  A bitmask of the 16 gpios whose direction mode is to be set 
        """
        return _pyupm_nlgpio16.NLGPIO16_gpioSetIODir(self, *args)

    def gpioWriteAll(self, *args):
        """
        gpioWriteAll(NLGPIO16 self, int mask)

        Parameters:
            mask: int


        void
        gpioWriteAll(int mask)

        Write all enabled gpios (set via gpioSetIOMask()) to a given value. A
        1 bit (LSB = gpio0) sets the given output to HIGH, a zero sets the
        given output to LOW. Only the gpios enabled by gpioSetMask() are
        affected by this call.

        Parameters:
        -----------

        mask:  The values to set for the 16 gpios (LSB = gpio0) 
        """
        return _pyupm_nlgpio16.NLGPIO16_gpioWriteAll(self, *args)

    def analogReadValue(self, *args):
        """
        analogReadValue(NLGPIO16 self, int adc) -> int

        Parameters:
            adc: int


        int
        analogReadValue(int adc)

        Read the raw analog input value present at the given gpio. The gpio is
        switched to analog input mode by this call, regardless of any previous
        mode. The returned value will be a number between 0-1023 (10 bit
        resolution). Only the first 7 gpios (0-6) can be used for analog
        input.

        Parameters:
        -----------

        adc:  The gpio number to read (0-6)

        The raw integer value from the ADC (0-1023) 
        """
        return _pyupm_nlgpio16.NLGPIO16_analogReadValue(self, *args)

    def analogReadVolts(self, *args):
        """
        analogReadVolts(NLGPIO16 self, int adc) -> float

        Parameters:
            adc: int


        float
        analogReadVolts(int adc)

        Read the raw analog input value present at the given gpio and return
        the coresponding voltage value at the pin. The gpio is switched to
        analog input mode by this call, regardless of any previous mode. The
        returned value will be a number between 0.0-3.3, depending on the
        voltage present at the pin. Only the first 7 gpios (0-6) can be used
        for analog input.

        Parameters:
        -----------

        adc:  The gpio number to read (0-6)

        The voltage present at the pin 
        """
        return _pyupm_nlgpio16.NLGPIO16_analogReadVolts(self, *args)

NLGPIO16_swigregister = _pyupm_nlgpio16.NLGPIO16_swigregister
NLGPIO16_swigregister(NLGPIO16)

class charArray(_object):
    """Proxy of C++ charArray class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, charArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, charArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(charArray self, size_t nelements) -> charArray

        Parameters:
            nelements: size_t

        """
        this = _pyupm_nlgpio16.new_charArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_nlgpio16.delete_charArray
    __del__ = lambda self : None;
    def __getitem__(self, *args):
        """
        __getitem__(charArray self, size_t index) -> char

        Parameters:
            index: size_t

        """
        return _pyupm_nlgpio16.charArray___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(charArray self, size_t index, char value)

        Parameters:
            index: size_t
            value: char

        """
        return _pyupm_nlgpio16.charArray___setitem__(self, *args)

    def cast(self):
        """
        cast(charArray self) -> char *

        Parameters:
            self: charArray *

        """
        return _pyupm_nlgpio16.charArray_cast(self)

    def frompointer(*args):
        """
        frompointer(char * t) -> charArray

        Parameters:
            t: char *

        """
        return _pyupm_nlgpio16.charArray_frompointer(*args)

    if _newclass:frompointer = staticmethod(frompointer)
    __swig_getmethods__["frompointer"] = lambda x: frompointer
charArray_swigregister = _pyupm_nlgpio16.charArray_swigregister
charArray_swigregister(charArray)

def charArray_frompointer(*args):
  """
    charArray_frompointer(char * t) -> charArray

    Parameters:
        t: char *

    """
  return _pyupm_nlgpio16.charArray_frompointer(*args)

# This file is compatible with both classic and new-style classes.


