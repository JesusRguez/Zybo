# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_mpu9150', [dirname(__file__)])
        except ImportError:
            import _pyupm_mpu9150
            return _pyupm_mpu9150
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_mpu9150', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_mpu9150 = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_mpu9150
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0



def new_floatp():
  """new_floatp() -> float *"""
  return _pyupm_mpu9150.new_floatp()

def copy_floatp(*args):
  """
    copy_floatp(float value) -> float *

    Parameters:
        value: float

    """
  return _pyupm_mpu9150.copy_floatp(*args)

def delete_floatp(*args):
  """
    delete_floatp(float * obj)

    Parameters:
        obj: float *

    """
  return _pyupm_mpu9150.delete_floatp(*args)

def floatp_assign(*args):
  """
    floatp_assign(float * obj, float value)

    Parameters:
        obj: float *
        value: float

    """
  return _pyupm_mpu9150.floatp_assign(*args)

def floatp_value(*args):
  """
    floatp_value(float * obj) -> float

    Parameters:
        obj: float *

    """
  return _pyupm_mpu9150.floatp_value(*args)
AK8975_I2C_BUS = _pyupm_mpu9150.AK8975_I2C_BUS
AK8975_DEFAULT_I2C_ADDR = _pyupm_mpu9150.AK8975_DEFAULT_I2C_ADDR
class AK8975(_object):
    """
    API for the AK8975 magnetometer.

    ID: ak8975

    Name: AK8975 3-axis Magnetometer

    Other Names: AK9875

    Category: compass

    Manufacturer: seeed

    Connection: i2c  This is a 3-axis magnetometer, which can be used
    alone, or coupled with another device (such as the mcu9150 9-axis
    motion sensor).

    C++ includes: ak8975.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AK8975, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AK8975, name)
    __repr__ = _swig_repr
    REG_WIA = _pyupm_mpu9150.AK8975_REG_WIA
    REG_INFO = _pyupm_mpu9150.AK8975_REG_INFO
    REG_ST1 = _pyupm_mpu9150.AK8975_REG_ST1
    REG_HXL = _pyupm_mpu9150.AK8975_REG_HXL
    REG_HXH = _pyupm_mpu9150.AK8975_REG_HXH
    REG_HYL = _pyupm_mpu9150.AK8975_REG_HYL
    REG_HYH = _pyupm_mpu9150.AK8975_REG_HYH
    REG_HZL = _pyupm_mpu9150.AK8975_REG_HZL
    REG_HZH = _pyupm_mpu9150.AK8975_REG_HZH
    REG_ST2 = _pyupm_mpu9150.AK8975_REG_ST2
    REG_CNTL = _pyupm_mpu9150.AK8975_REG_CNTL
    REG_ASTC = _pyupm_mpu9150.AK8975_REG_ASTC
    REG_ASAX = _pyupm_mpu9150.AK8975_REG_ASAX
    REG_ASAY = _pyupm_mpu9150.AK8975_REG_ASAY
    REG_ASAZ = _pyupm_mpu9150.AK8975_REG_ASAZ
    ST1_DRDY = _pyupm_mpu9150.AK8975_ST1_DRDY
    ST2_DERR = _pyupm_mpu9150.AK8975_ST2_DERR
    ST2_HOFL = _pyupm_mpu9150.AK8975_ST2_HOFL
    CNTL_PWRDWN = _pyupm_mpu9150.AK8975_CNTL_PWRDWN
    CNTL_MEASURE = _pyupm_mpu9150.AK8975_CNTL_MEASURE
    CNTL_SELFTEST = _pyupm_mpu9150.AK8975_CNTL_SELFTEST
    CNTL_FUSE_ACCESS = _pyupm_mpu9150.AK8975_CNTL_FUSE_ACCESS
    ASTC_SELF = _pyupm_mpu9150.AK8975_ASTC_SELF
    def __init__(self, bus=0, address=0x0c): 
        """
        __init__(upm::AK8975 self, int bus=0, uint8_t address=0x0c) -> AK8975

        Parameters:
            bus: int
            address: uint8_t

        __init__(upm::AK8975 self, int bus=0) -> AK8975

        Parameters:
            bus: int

        __init__(upm::AK8975 self) -> AK8975

        AK8975(int
        bus=AK8975_I2C_BUS, uint8_t address=AK8975_DEFAULT_I2C_ADDR)

        ak8975 constructor

        Parameters:
        -----------

        bus:  i2c bus to use

        address:  the address for this device 
        """
        this = _pyupm_mpu9150.new_AK8975(bus, address)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_mpu9150.delete_AK8975
    __del__ = lambda self : None;
    def init(self):
        """
        init(AK8975 self) -> bool

        Parameters:
            self: upm::AK8975 *


        bool init()

        set up initial values and start operation

        Parameters:
        -----------

        dsr:  the data sampling rate: one of the DSR_BITS_T values

        true if successful 
        """
        return _pyupm_mpu9150.AK8975_init(self)

    def setMode(self, *args):
        """
        setMode(AK8975 self, upm::AK8975::CNTL_MODES_T mode) -> bool

        Parameters:
            mode: enum upm::AK8975::CNTL_MODES_T


        bool
        setMode(CNTL_MODES_T mode)

        put the chip into a specific mode

        Parameters:
        -----------

        mode:  one of the CNTL_MODES_T values

        true if successful 
        """
        return _pyupm_mpu9150.AK8975_setMode(self, *args)

    def isReady(self):
        """
        isReady(AK8975 self) -> bool

        Parameters:
            self: upm::AK8975 *


        bool isReady()

        check to see if the ST1_DRDY bit is set, indicating the device can
        accept commands

        true if device is ready, false otherwise 
        """
        return _pyupm_mpu9150.AK8975_isReady(self)

    def waitforDeviceReady(self):
        """
        waitforDeviceReady(AK8975 self) -> bool

        Parameters:
            self: upm::AK8975 *


        bool
        waitforDeviceReady()

        check to see if device is ready and sleep/retry if not. Returns once
        device indicates it's ready.

        true if device is ready, false if retries exhausted 
        """
        return _pyupm_mpu9150.AK8975_waitforDeviceReady(self)

    def update(self, selfTest=False):
        """
        update(AK8975 self, bool selfTest=False) -> bool

        Parameters:
            selfTest: bool

        update(AK8975 self) -> bool

        Parameters:
            self: upm::AK8975 *


        bool update(bool
        selfTest=false)

        take a measurement

        Parameters:
        -----------

        selfTest:  true if we are running a self test, false (default)
        otherwise.

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.AK8975_update(self, selfTest)

    def selfTest(self):
        """
        selfTest(AK8975 self) -> bool

        Parameters:
            self: upm::AK8975 *


        bool selfTest()

        do a self test sequence. When self test is executed, the device
        activates internal calibrated magnets, and measures them, updating the
        measurement registers. Once complete, the data can be read as usual (
        getMagnetometer()) and the returned values compared against the
        following limits to determine correctness:

        -100 < X < +100; -100 < Y < +100; -1000 < Z < -300

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.AK8975_selfTest(self)

    def getMagnetometer(self, *args):
        """
        getMagnetometer(AK8975 self, float * x, float * y, float * z)

        Parameters:
            x: float *
            y: float *
            z: float *


        void
        getMagnetometer(float *x, float *y, float *z)

        return the compensated values for the x, y, and z axes. The unit of
        measurement is in micro-teslas (uT).

        Parameters:
        -----------

        x:  pointer to returned X axis value

        y:  pointer to returned Y axis value

        z:  pointer to returned Z axis value 
        """
        return _pyupm_mpu9150.AK8975_getMagnetometer(self, *args)

AK8975_swigregister = _pyupm_mpu9150.AK8975_swigregister
AK8975_swigregister(AK8975)

MPU60X0_I2C_BUS = _pyupm_mpu9150.MPU60X0_I2C_BUS
MPU60X0_DEFAULT_I2C_ADDR = _pyupm_mpu9150.MPU60X0_DEFAULT_I2C_ADDR
class MPU60X0(_object):
    """
    API for the MPU60X0 3-axis Gyroscope and 3-axis Accelerometer.

    ID: mpu60x0

    Name: MPU60X0 3-axis Gyroscope and 3-axis Accelerometer

    Category: accelerometer compass

    Manufacturer: seeed

    Connection: i2c gpio  The MPU60X0 devices provide the worldâ€™s first
    integrated 6-axis motion processor solution that eliminates the
    package-level gyroscope and accelerometer cross-axis misalignment
    associated with discrete solutions. The devices combine a 3-axis
    gyroscope and a 3-axis accelerometer on the same silicon die.

    While not all of the functionality of this device is supported
    initially, methods and register definitions are provided that should
    allow an end user to implement whatever features are required.

    C++ includes: mpu60x0.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MPU60X0, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MPU60X0, name)
    __repr__ = _swig_repr
    REG_SELF_TEST_X = _pyupm_mpu9150.MPU60X0_REG_SELF_TEST_X
    REG_SELF_TEST_Y = _pyupm_mpu9150.MPU60X0_REG_SELF_TEST_Y
    REG_SELF_TEST_Z = _pyupm_mpu9150.MPU60X0_REG_SELF_TEST_Z
    REG_SELF_TEST_A = _pyupm_mpu9150.MPU60X0_REG_SELF_TEST_A
    REG_SMPLRT_DIV = _pyupm_mpu9150.MPU60X0_REG_SMPLRT_DIV
    REG_CONFIG = _pyupm_mpu9150.MPU60X0_REG_CONFIG
    REG_GYRO_CONFIG = _pyupm_mpu9150.MPU60X0_REG_GYRO_CONFIG
    REG_ACCEL_CONFIG = _pyupm_mpu9150.MPU60X0_REG_ACCEL_CONFIG
    REG_FF_THR = _pyupm_mpu9150.MPU60X0_REG_FF_THR
    REG_FF_DUR = _pyupm_mpu9150.MPU60X0_REG_FF_DUR
    REG_MOT_THR = _pyupm_mpu9150.MPU60X0_REG_MOT_THR
    REG_MOT_DUR = _pyupm_mpu9150.MPU60X0_REG_MOT_DUR
    REG_ZRMOT_THR = _pyupm_mpu9150.MPU60X0_REG_ZRMOT_THR
    REG_ZRMOT_DUR = _pyupm_mpu9150.MPU60X0_REG_ZRMOT_DUR
    REG_FIFO_EN = _pyupm_mpu9150.MPU60X0_REG_FIFO_EN
    REG_I2C_MST_CTRL = _pyupm_mpu9150.MPU60X0_REG_I2C_MST_CTRL
    REG_I2C_SLV0_ADDR = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV0_ADDR
    REG_I2C_SLV0_REG = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV0_REG
    REG_I2C_SLV0_CTRL = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV0_CTRL
    REG_I2C_SLV1_ADDR = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV1_ADDR
    REG_I2C_SLV1_REG = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV1_REG
    REG_I2C_SLV1_CTRL = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV1_CTRL
    REG_I2C_SLV2_ADDR = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV2_ADDR
    REG_I2C_SLV2_REG = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV2_REG
    REG_I2C_SLV2_CTRL = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV2_CTRL
    REG_I2C_SLV3_ADDR = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV3_ADDR
    REG_I2C_SLV3_REG = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV3_REG
    REG_I2C_SLV3_CTRL = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV3_CTRL
    REG_I2C_SLV4_ADDR = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV4_ADDR
    REG_I2C_SLV4_REG = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV4_REG
    REG_I2C_SLV4_DO = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV4_DO
    REG_I2C_SLV4_CTRL = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV4_CTRL
    REG_I2C_SLV4_DI = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV4_DI
    REG_I2C_MST_STATUS = _pyupm_mpu9150.MPU60X0_REG_I2C_MST_STATUS
    REG_INT_PIN_CFG = _pyupm_mpu9150.MPU60X0_REG_INT_PIN_CFG
    REG_INT_ENABLE = _pyupm_mpu9150.MPU60X0_REG_INT_ENABLE
    REG_INT_STATUS = _pyupm_mpu9150.MPU60X0_REG_INT_STATUS
    REG_ACCEL_XOUT_H = _pyupm_mpu9150.MPU60X0_REG_ACCEL_XOUT_H
    REG_ACCEL_XOUT_L = _pyupm_mpu9150.MPU60X0_REG_ACCEL_XOUT_L
    REG_ACCEL_YOUT_H = _pyupm_mpu9150.MPU60X0_REG_ACCEL_YOUT_H
    REG_ACCEL_YOUT_L = _pyupm_mpu9150.MPU60X0_REG_ACCEL_YOUT_L
    REG_ACCEL_ZOUT_H = _pyupm_mpu9150.MPU60X0_REG_ACCEL_ZOUT_H
    REG_ACCEL_ZOUT_L = _pyupm_mpu9150.MPU60X0_REG_ACCEL_ZOUT_L
    REG_TEMP_OUT_H = _pyupm_mpu9150.MPU60X0_REG_TEMP_OUT_H
    REG_TEMP_OUT_L = _pyupm_mpu9150.MPU60X0_REG_TEMP_OUT_L
    REG_GYRO_XOUT_H = _pyupm_mpu9150.MPU60X0_REG_GYRO_XOUT_H
    REG_GYRO_XOUT_L = _pyupm_mpu9150.MPU60X0_REG_GYRO_XOUT_L
    REG_GYRO_YOUT_H = _pyupm_mpu9150.MPU60X0_REG_GYRO_YOUT_H
    REG_GYRO_YOUT_L = _pyupm_mpu9150.MPU60X0_REG_GYRO_YOUT_L
    REG_GYRO_ZOUT_H = _pyupm_mpu9150.MPU60X0_REG_GYRO_ZOUT_H
    REG_GYRO_ZOUT_L = _pyupm_mpu9150.MPU60X0_REG_GYRO_ZOUT_L
    REG_EXT_SENS_DATA_00 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_00
    REG_EXT_SENS_DATA_01 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_01
    REG_EXT_SENS_DATA_02 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_02
    REG_EXT_SENS_DATA_03 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_03
    REG_EXT_SENS_DATA_04 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_04
    REG_EXT_SENS_DATA_05 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_05
    REG_EXT_SENS_DATA_06 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_06
    REG_EXT_SENS_DATA_07 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_07
    REG_EXT_SENS_DATA_08 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_08
    REG_EXT_SENS_DATA_09 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_09
    REG_EXT_SENS_DATA_10 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_10
    REG_EXT_SENS_DATA_11 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_11
    REG_EXT_SENS_DATA_12 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_12
    REG_EXT_SENS_DATA_13 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_13
    REG_EXT_SENS_DATA_14 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_14
    REG_EXT_SENS_DATA_15 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_15
    REG_EXT_SENS_DATA_16 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_16
    REG_EXT_SENS_DATA_17 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_17
    REG_EXT_SENS_DATA_18 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_18
    REG_EXT_SENS_DATA_19 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_19
    REG_EXT_SENS_DATA_20 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_20
    REG_EXT_SENS_DATA_21 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_21
    REG_EXT_SENS_DATA_22 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_22
    REG_EXT_SENS_DATA_23 = _pyupm_mpu9150.MPU60X0_REG_EXT_SENS_DATA_23
    REG_MOT_DETECT_STATUS = _pyupm_mpu9150.MPU60X0_REG_MOT_DETECT_STATUS
    REG_I2C_SLV0_DO = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV0_DO
    REG_I2C_SLV1_DO = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV1_DO
    REG_I2C_SLV2_DO = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV2_DO
    REG_I2C_SLV3_DO = _pyupm_mpu9150.MPU60X0_REG_I2C_SLV3_DO
    REG_I2C_MST_DELAY_CTRL = _pyupm_mpu9150.MPU60X0_REG_I2C_MST_DELAY_CTRL
    REG_SIGNAL_PATH_RESET = _pyupm_mpu9150.MPU60X0_REG_SIGNAL_PATH_RESET
    REG_MOT_DETECT_CTRL = _pyupm_mpu9150.MPU60X0_REG_MOT_DETECT_CTRL
    REG_USER_CTRL = _pyupm_mpu9150.MPU60X0_REG_USER_CTRL
    REG_PWR_MGMT_1 = _pyupm_mpu9150.MPU60X0_REG_PWR_MGMT_1
    REG_PWR_MGMT_2 = _pyupm_mpu9150.MPU60X0_REG_PWR_MGMT_2
    REG_FIFO_COUNTH = _pyupm_mpu9150.MPU60X0_REG_FIFO_COUNTH
    REG_FIFO_COUNTL = _pyupm_mpu9150.MPU60X0_REG_FIFO_COUNTL
    REG_FIFO_R_W = _pyupm_mpu9150.MPU60X0_REG_FIFO_R_W
    REG_WHO_AM_I = _pyupm_mpu9150.MPU60X0_REG_WHO_AM_I
    CONFIG_DLPF_CFG0 = _pyupm_mpu9150.MPU60X0_CONFIG_DLPF_CFG0
    CONFIG_DLPF_CFG1 = _pyupm_mpu9150.MPU60X0_CONFIG_DLPF_CFG1
    CONFIG_DLPF_CFG2 = _pyupm_mpu9150.MPU60X0_CONFIG_DLPF_CFG2
    _CONFIG_DLPF_SHIFT = _pyupm_mpu9150.MPU60X0__CONFIG_DLPF_SHIFT
    _CONFIG_DLPF_MASK = _pyupm_mpu9150.MPU60X0__CONFIG_DLPF_MASK
    CONFIG_EXT_SYNC_SET0 = _pyupm_mpu9150.MPU60X0_CONFIG_EXT_SYNC_SET0
    CONFIG_EXT_SYNC_SET1 = _pyupm_mpu9150.MPU60X0_CONFIG_EXT_SYNC_SET1
    CONFIG_EXT_SYNC_SET2 = _pyupm_mpu9150.MPU60X0_CONFIG_EXT_SYNC_SET2
    _CONFIG_EXT_SYNC_SET_SHIFT = _pyupm_mpu9150.MPU60X0__CONFIG_EXT_SYNC_SET_SHIFT
    _CONFIG_EXT_SYNC_SET_MASK = _pyupm_mpu9150.MPU60X0__CONFIG_EXT_SYNC_SET_MASK
    DLPF_260_256 = _pyupm_mpu9150.MPU60X0_DLPF_260_256
    DLPF_184_188 = _pyupm_mpu9150.MPU60X0_DLPF_184_188
    DLPF_94_98 = _pyupm_mpu9150.MPU60X0_DLPF_94_98
    DLPF_44_42 = _pyupm_mpu9150.MPU60X0_DLPF_44_42
    DLPF_21_20 = _pyupm_mpu9150.MPU60X0_DLPF_21_20
    DLPF_10_10 = _pyupm_mpu9150.MPU60X0_DLPF_10_10
    DLPF_5_5 = _pyupm_mpu9150.MPU60X0_DLPF_5_5
    DLPF_RESERVED = _pyupm_mpu9150.MPU60X0_DLPF_RESERVED
    EXT_SYNC_DISABLED = _pyupm_mpu9150.MPU60X0_EXT_SYNC_DISABLED
    EXT_SYNC_TEMP_OUT = _pyupm_mpu9150.MPU60X0_EXT_SYNC_TEMP_OUT
    EXT_SYNC_GYRO_XOUT = _pyupm_mpu9150.MPU60X0_EXT_SYNC_GYRO_XOUT
    EXT_SYNC_GYRO_YOUT = _pyupm_mpu9150.MPU60X0_EXT_SYNC_GYRO_YOUT
    EXT_SYNC_GYRO_ZOUT = _pyupm_mpu9150.MPU60X0_EXT_SYNC_GYRO_ZOUT
    EXT_SYNC_ACCEL_XOUT = _pyupm_mpu9150.MPU60X0_EXT_SYNC_ACCEL_XOUT
    EXT_SYNC_ACCEL_YOUT = _pyupm_mpu9150.MPU60X0_EXT_SYNC_ACCEL_YOUT
    EXT_SYNC_ACCEL_ZOUT = _pyupm_mpu9150.MPU60X0_EXT_SYNC_ACCEL_ZOUT
    FS_SEL0 = _pyupm_mpu9150.MPU60X0_FS_SEL0
    FS_SEL1 = _pyupm_mpu9150.MPU60X0_FS_SEL1
    _FS_SEL_SHIFT = _pyupm_mpu9150.MPU60X0__FS_SEL_SHIFT
    _FS_SEL_MASK = _pyupm_mpu9150.MPU60X0__FS_SEL_MASK
    ZG_ST = _pyupm_mpu9150.MPU60X0_ZG_ST
    YG_ST = _pyupm_mpu9150.MPU60X0_YG_ST
    XG_ST = _pyupm_mpu9150.MPU60X0_XG_ST
    FS_250 = _pyupm_mpu9150.MPU60X0_FS_250
    FS_500 = _pyupm_mpu9150.MPU60X0_FS_500
    FS_1000 = _pyupm_mpu9150.MPU60X0_FS_1000
    FS_2000 = _pyupm_mpu9150.MPU60X0_FS_2000
    AFS_SEL0 = _pyupm_mpu9150.MPU60X0_AFS_SEL0
    AFS_SEL1 = _pyupm_mpu9150.MPU60X0_AFS_SEL1
    _AFS_SEL_SHIFT = _pyupm_mpu9150.MPU60X0__AFS_SEL_SHIFT
    _AFS_SEL_MASK = _pyupm_mpu9150.MPU60X0__AFS_SEL_MASK
    ZA_ST = _pyupm_mpu9150.MPU60X0_ZA_ST
    YA_ST = _pyupm_mpu9150.MPU60X0_YA_ST
    XA_ST = _pyupm_mpu9150.MPU60X0_XA_ST
    AFS_2 = _pyupm_mpu9150.MPU60X0_AFS_2
    AFS_4 = _pyupm_mpu9150.MPU60X0_AFS_4
    AFS_8 = _pyupm_mpu9150.MPU60X0_AFS_8
    AFS_16 = _pyupm_mpu9150.MPU60X0_AFS_16
    SLV0_FIFO_EN = _pyupm_mpu9150.MPU60X0_SLV0_FIFO_EN
    SLV1_FIFO_EN = _pyupm_mpu9150.MPU60X0_SLV1_FIFO_EN
    SLV2_FIFO_EN = _pyupm_mpu9150.MPU60X0_SLV2_FIFO_EN
    ACCEL_FIFO_EN = _pyupm_mpu9150.MPU60X0_ACCEL_FIFO_EN
    ZG_FIFO_EN = _pyupm_mpu9150.MPU60X0_ZG_FIFO_EN
    YG_FIFO_EN = _pyupm_mpu9150.MPU60X0_YG_FIFO_EN
    XG_FIFO_EN = _pyupm_mpu9150.MPU60X0_XG_FIFO_EN
    TEMP_FIFO_EN = _pyupm_mpu9150.MPU60X0_TEMP_FIFO_EN
    I2C_MST_CLK0 = _pyupm_mpu9150.MPU60X0_I2C_MST_CLK0
    I2C_MST_CLK1 = _pyupm_mpu9150.MPU60X0_I2C_MST_CLK1
    I2C_MST_CLK2 = _pyupm_mpu9150.MPU60X0_I2C_MST_CLK2
    I2C_MST_CLK3 = _pyupm_mpu9150.MPU60X0_I2C_MST_CLK3
    _I2C_MST_CLK_SHIFT = _pyupm_mpu9150.MPU60X0__I2C_MST_CLK_SHIFT
    _I2C_MST_CLK_MASK = _pyupm_mpu9150.MPU60X0__I2C_MST_CLK_MASK
    I2C_MST_P_NSR = _pyupm_mpu9150.MPU60X0_I2C_MST_P_NSR
    SLV_3_FIFO_EN = _pyupm_mpu9150.MPU60X0_SLV_3_FIFO_EN
    WAIT_FOR_ES = _pyupm_mpu9150.MPU60X0_WAIT_FOR_ES
    MULT_MST_EN = _pyupm_mpu9150.MPU60X0_MULT_MST_EN
    MST_CLK_348 = _pyupm_mpu9150.MPU60X0_MST_CLK_348
    MST_CLK_333 = _pyupm_mpu9150.MPU60X0_MST_CLK_333
    MST_CLK_320 = _pyupm_mpu9150.MPU60X0_MST_CLK_320
    MST_CLK_308 = _pyupm_mpu9150.MPU60X0_MST_CLK_308
    MST_CLK_296 = _pyupm_mpu9150.MPU60X0_MST_CLK_296
    MST_CLK_286 = _pyupm_mpu9150.MPU60X0_MST_CLK_286
    MST_CLK_276 = _pyupm_mpu9150.MPU60X0_MST_CLK_276
    MST_CLK_267 = _pyupm_mpu9150.MPU60X0_MST_CLK_267
    MST_CLK_258 = _pyupm_mpu9150.MPU60X0_MST_CLK_258
    MST_CLK_500 = _pyupm_mpu9150.MPU60X0_MST_CLK_500
    MST_CLK_471 = _pyupm_mpu9150.MPU60X0_MST_CLK_471
    MST_CLK_444 = _pyupm_mpu9150.MPU60X0_MST_CLK_444
    MST_CLK_421 = _pyupm_mpu9150.MPU60X0_MST_CLK_421
    MST_CLK_400 = _pyupm_mpu9150.MPU60X0_MST_CLK_400
    MST_CLK_381 = _pyupm_mpu9150.MPU60X0_MST_CLK_381
    MST_CLK_364 = _pyupm_mpu9150.MPU60X0_MST_CLK_364
    I2C_SLV_ADDR0 = _pyupm_mpu9150.MPU60X0_I2C_SLV_ADDR0
    I2C_SLV_ADDR1 = _pyupm_mpu9150.MPU60X0_I2C_SLV_ADDR1
    I2C_SLV_ADDR2 = _pyupm_mpu9150.MPU60X0_I2C_SLV_ADDR2
    I2C_SLV_ADDR3 = _pyupm_mpu9150.MPU60X0_I2C_SLV_ADDR3
    I2C_SLV_ADDR4 = _pyupm_mpu9150.MPU60X0_I2C_SLV_ADDR4
    I2C_SLV_ADDR5 = _pyupm_mpu9150.MPU60X0_I2C_SLV_ADDR5
    I2C_SLV_ADDR6 = _pyupm_mpu9150.MPU60X0_I2C_SLV_ADDR6
    _I2C_SLV_ADDR_SHIFT = _pyupm_mpu9150.MPU60X0__I2C_SLV_ADDR_SHIFT
    _I2C_SLV_ADDR_MASK = _pyupm_mpu9150.MPU60X0__I2C_SLV_ADDR_MASK
    I2C_SLV_RW = _pyupm_mpu9150.MPU60X0_I2C_SLV_RW
    I2C_SLV_LEN0 = _pyupm_mpu9150.MPU60X0_I2C_SLV_LEN0
    I2C_SLV_LEN1 = _pyupm_mpu9150.MPU60X0_I2C_SLV_LEN1
    I2C_SLV_LEN2 = _pyupm_mpu9150.MPU60X0_I2C_SLV_LEN2
    I2C_SLV_LEN3 = _pyupm_mpu9150.MPU60X0_I2C_SLV_LEN3
    _I2C_SLV_LEN_SHIFT = _pyupm_mpu9150.MPU60X0__I2C_SLV_LEN_SHIFT
    _I2C_SLV_LEN_MASK = _pyupm_mpu9150.MPU60X0__I2C_SLV_LEN_MASK
    I2C_SLV_GRP = _pyupm_mpu9150.MPU60X0_I2C_SLV_GRP
    I2C_SLV_REG_DIS = _pyupm_mpu9150.MPU60X0_I2C_SLV_REG_DIS
    I2C_SLV_BYTE_SW = _pyupm_mpu9150.MPU60X0_I2C_SLV_BYTE_SW
    I2C_SLV_EN = _pyupm_mpu9150.MPU60X0_I2C_SLV_EN
    I2C_MST_DLY0 = _pyupm_mpu9150.MPU60X0_I2C_MST_DLY0
    I2C_MST_DLY1 = _pyupm_mpu9150.MPU60X0_I2C_MST_DLY1
    I2C_MST_DLY2 = _pyupm_mpu9150.MPU60X0_I2C_MST_DLY2
    I2C_MST_DLY3 = _pyupm_mpu9150.MPU60X0_I2C_MST_DLY3
    I2C_MST_DLY4 = _pyupm_mpu9150.MPU60X0_I2C_MST_DLY4
    _I2C_MST_DLY_SHIFT = _pyupm_mpu9150.MPU60X0__I2C_MST_DLY_SHIFT
    _I2C_MST_DLY_MASK = _pyupm_mpu9150.MPU60X0__I2C_MST_DLY_MASK
    I2C_SLV4_REG_DIS = _pyupm_mpu9150.MPU60X0_I2C_SLV4_REG_DIS
    I2C_SLV4_INT_EN = _pyupm_mpu9150.MPU60X0_I2C_SLV4_INT_EN
    I2C_SLV4_EN = _pyupm_mpu9150.MPU60X0_I2C_SLV4_EN
    I2C_SLV0_NACK = _pyupm_mpu9150.MPU60X0_I2C_SLV0_NACK
    I2C_SLV1_NACK = _pyupm_mpu9150.MPU60X0_I2C_SLV1_NACK
    I2C_SLV2_NACK = _pyupm_mpu9150.MPU60X0_I2C_SLV2_NACK
    I2C_SLV3_NACK = _pyupm_mpu9150.MPU60X0_I2C_SLV3_NACK
    I2C_SLV4_NACK = _pyupm_mpu9150.MPU60X0_I2C_SLV4_NACK
    I2C_LOST_ARB = _pyupm_mpu9150.MPU60X0_I2C_LOST_ARB
    I2C_SLV4_DONE = _pyupm_mpu9150.MPU60X0_I2C_SLV4_DONE
    PASS_THROUGH = _pyupm_mpu9150.MPU60X0_PASS_THROUGH
    CLKOUT_EN = _pyupm_mpu9150.MPU60X0_CLKOUT_EN
    I2C_BYPASS_ENABLE = _pyupm_mpu9150.MPU60X0_I2C_BYPASS_ENABLE
    FSYNC_INT_EN = _pyupm_mpu9150.MPU60X0_FSYNC_INT_EN
    FSYNC_INT_LEVEL = _pyupm_mpu9150.MPU60X0_FSYNC_INT_LEVEL
    INT_RD_CLEAR = _pyupm_mpu9150.MPU60X0_INT_RD_CLEAR
    LATCH_INT_EN = _pyupm_mpu9150.MPU60X0_LATCH_INT_EN
    INT_OPEN = _pyupm_mpu9150.MPU60X0_INT_OPEN
    INT_LEVEL = _pyupm_mpu9150.MPU60X0_INT_LEVEL
    DATA_RDY_EN = _pyupm_mpu9150.MPU60X0_DATA_RDY_EN
    I2C_MST_INT_EN = _pyupm_mpu9150.MPU60X0_I2C_MST_INT_EN
    FIFO_OFLOW_EN = _pyupm_mpu9150.MPU60X0_FIFO_OFLOW_EN
    ZMOT_EN = _pyupm_mpu9150.MPU60X0_ZMOT_EN
    MOT_EN = _pyupm_mpu9150.MPU60X0_MOT_EN
    FF_EN = _pyupm_mpu9150.MPU60X0_FF_EN
    DATA_RDY_INT = _pyupm_mpu9150.MPU60X0_DATA_RDY_INT
    I2C_MST_INT = _pyupm_mpu9150.MPU60X0_I2C_MST_INT
    FIFO_OFLOW_INT = _pyupm_mpu9150.MPU60X0_FIFO_OFLOW_INT
    ZMOT_INT = _pyupm_mpu9150.MPU60X0_ZMOT_INT
    MOT_INT = _pyupm_mpu9150.MPU60X0_MOT_INT
    FF_INT = _pyupm_mpu9150.MPU60X0_FF_INT
    MOT_ZRMOT = _pyupm_mpu9150.MPU60X0_MOT_ZRMOT
    MOT_ZPOS = _pyupm_mpu9150.MPU60X0_MOT_ZPOS
    MOT_ZNEG = _pyupm_mpu9150.MPU60X0_MOT_ZNEG
    MOT_YPOS = _pyupm_mpu9150.MPU60X0_MOT_YPOS
    MOT_YNEG = _pyupm_mpu9150.MPU60X0_MOT_YNEG
    MOT_XPOS = _pyupm_mpu9150.MPU60X0_MOT_XPOS
    MOT_XNEG = _pyupm_mpu9150.MPU60X0_MOT_XNEG
    I2C_SLV0_DLY_EN = _pyupm_mpu9150.MPU60X0_I2C_SLV0_DLY_EN
    I2C_SLV1_DLY_EN = _pyupm_mpu9150.MPU60X0_I2C_SLV1_DLY_EN
    I2C_SLV2_DLY_EN = _pyupm_mpu9150.MPU60X0_I2C_SLV2_DLY_EN
    I2C_SLV3_DLY_EN = _pyupm_mpu9150.MPU60X0_I2C_SLV3_DLY_EN
    I2C_SLV4_DLY_EN = _pyupm_mpu9150.MPU60X0_I2C_SLV4_DLY_EN
    DELAY_ES_SHADOW = _pyupm_mpu9150.MPU60X0_DELAY_ES_SHADOW
    TEMP_RESET = _pyupm_mpu9150.MPU60X0_TEMP_RESET
    ACCEL_RESET = _pyupm_mpu9150.MPU60X0_ACCEL_RESET
    GYRO_RESET = _pyupm_mpu9150.MPU60X0_GYRO_RESET
    MOT_COUNT0 = _pyupm_mpu9150.MPU60X0_MOT_COUNT0
    MOT_COUNT1 = _pyupm_mpu9150.MPU60X0_MOT_COUNT1
    _MOT_COUNT_SHIFT = _pyupm_mpu9150.MPU60X0__MOT_COUNT_SHIFT
    _MOT_COUNT_MASK = _pyupm_mpu9150.MPU60X0__MOT_COUNT_MASK
    FF_COUNT0 = _pyupm_mpu9150.MPU60X0_FF_COUNT0
    FF_COUNT1 = _pyupm_mpu9150.MPU60X0_FF_COUNT1
    _FF_COUNT_SHIFT = _pyupm_mpu9150.MPU60X0__FF_COUNT_SHIFT
    _FF_COUNT_MASK = _pyupm_mpu9150.MPU60X0__FF_COUNT_MASK
    ACCEL_ON_DELAY0 = _pyupm_mpu9150.MPU60X0_ACCEL_ON_DELAY0
    ACCEL_ON_DELAY1 = _pyupm_mpu9150.MPU60X0_ACCEL_ON_DELAY1
    _ACCEL_ON_DELAY_SHIFT = _pyupm_mpu9150.MPU60X0__ACCEL_ON_DELAY_SHIFT
    _ACCEL_ON_DELAY_MASK = _pyupm_mpu9150.MPU60X0__ACCEL_ON_DELAY_MASK
    COUNT_0 = _pyupm_mpu9150.MPU60X0_COUNT_0
    COUNT_1 = _pyupm_mpu9150.MPU60X0_COUNT_1
    COUNT_2 = _pyupm_mpu9150.MPU60X0_COUNT_2
    COUNT_4 = _pyupm_mpu9150.MPU60X0_COUNT_4
    ON_DELAY_0 = _pyupm_mpu9150.MPU60X0_ON_DELAY_0
    ON_DELAY_1 = _pyupm_mpu9150.MPU60X0_ON_DELAY_1
    ON_DELAY_2 = _pyupm_mpu9150.MPU60X0_ON_DELAY_2
    ON_DELAY_3 = _pyupm_mpu9150.MPU60X0_ON_DELAY_3
    SIG_COND_RESET = _pyupm_mpu9150.MPU60X0_SIG_COND_RESET
    I2C_MST_RESET = _pyupm_mpu9150.MPU60X0_I2C_MST_RESET
    FIFO_RESET = _pyupm_mpu9150.MPU60X0_FIFO_RESET
    I2C_IF_DIS = _pyupm_mpu9150.MPU60X0_I2C_IF_DIS
    I2C_MST_EN = _pyupm_mpu9150.MPU60X0_I2C_MST_EN
    FIFO_EN = _pyupm_mpu9150.MPU60X0_FIFO_EN
    CLKSEL0 = _pyupm_mpu9150.MPU60X0_CLKSEL0
    CLKSEL1 = _pyupm_mpu9150.MPU60X0_CLKSEL1
    CLKSEL2 = _pyupm_mpu9150.MPU60X0_CLKSEL2
    _CLKSEL_SHIFT = _pyupm_mpu9150.MPU60X0__CLKSEL_SHIFT
    _CLKSEL_MASK = _pyupm_mpu9150.MPU60X0__CLKSEL_MASK
    TEMP_DIS = _pyupm_mpu9150.MPU60X0_TEMP_DIS
    PWR_CYCLE = _pyupm_mpu9150.MPU60X0_PWR_CYCLE
    PWR_SLEEP = _pyupm_mpu9150.MPU60X0_PWR_SLEEP
    DEVICE_RESET = _pyupm_mpu9150.MPU60X0_DEVICE_RESET
    INT_8MHZ = _pyupm_mpu9150.MPU60X0_INT_8MHZ
    PLL_XG = _pyupm_mpu9150.MPU60X0_PLL_XG
    PLL_YG = _pyupm_mpu9150.MPU60X0_PLL_YG
    PLL_ZG = _pyupm_mpu9150.MPU60X0_PLL_ZG
    PLL_EXT_32KHZ = _pyupm_mpu9150.MPU60X0_PLL_EXT_32KHZ
    PLL_EXT_19MHZ = _pyupm_mpu9150.MPU60X0_PLL_EXT_19MHZ
    CLK_STOP = _pyupm_mpu9150.MPU60X0_CLK_STOP
    STBY_ZG = _pyupm_mpu9150.MPU60X0_STBY_ZG
    STBY_YG = _pyupm_mpu9150.MPU60X0_STBY_YG
    STBY_XG = _pyupm_mpu9150.MPU60X0_STBY_XG
    STBY_ZA = _pyupm_mpu9150.MPU60X0_STBY_ZA
    STBY_YA = _pyupm_mpu9150.MPU60X0_STBY_YA
    STBY_XA = _pyupm_mpu9150.MPU60X0_STBY_XA
    LP_WAKE_CTRL0 = _pyupm_mpu9150.MPU60X0_LP_WAKE_CTRL0
    LP_WAKE_CTRL1 = _pyupm_mpu9150.MPU60X0_LP_WAKE_CTRL1
    _LP_WAKE_CTRL_SHIFT = _pyupm_mpu9150.MPU60X0__LP_WAKE_CTRL_SHIFT
    _LP_WAKE_CTRL_MASK = _pyupm_mpu9150.MPU60X0__LP_WAKE_CTRL_MASK
    LP_WAKE_1_25 = _pyupm_mpu9150.MPU60X0_LP_WAKE_1_25
    LP_WAKE_5 = _pyupm_mpu9150.MPU60X0_LP_WAKE_5
    LP_WAKE_20 = _pyupm_mpu9150.MPU60X0_LP_WAKE_20
    LP_WAKE_40 = _pyupm_mpu9150.MPU60X0_LP_WAKE_40
    def __init__(self, bus=0, address=0x68): 
        """
        __init__(upm::MPU60X0 self, int bus=0, uint8_t address=0x68) -> MPU60X0

        Parameters:
            bus: int
            address: uint8_t

        __init__(upm::MPU60X0 self, int bus=0) -> MPU60X0

        Parameters:
            bus: int

        __init__(upm::MPU60X0 self) -> MPU60X0

        MPU60X0(int
        bus=MPU60X0_I2C_BUS, uint8_t address=MPU60X0_DEFAULT_I2C_ADDR)

        mpu60x0 constructor

        Parameters:
        -----------

        bus:  i2c bus to use

        address:  the address for this device 
        """
        this = _pyupm_mpu9150.new_MPU60X0(bus, address)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_mpu9150.delete_MPU60X0
    __del__ = lambda self : None;
    def init(self):
        """
        init(MPU60X0 self) -> bool

        Parameters:
            self: upm::MPU60X0 *


        bool init()

        set up initial values and start operation

        true if successful 
        """
        return _pyupm_mpu9150.MPU60X0_init(self)

    def update(self):
        """
        update(MPU60X0 self)

        Parameters:
            self: upm::MPU60X0 *


        void update()

        take a measurement and store the current sensor values internally.
        Note, these user facing registers are only updated from the internal
        device sensor values when the i2c serial traffic is 'idle'. So, if you
        are reading the values too fast, the bus may never be idle, and you
        will just end up reading the same values over and over.

        Unfortunately, it is is not clear how long 'idle' actually means, so
        if you see this behavior, reduce the rate at which you are calling
        update(). 
        """
        return _pyupm_mpu9150.MPU60X0_update(self)

    def readReg(self, *args):
        """
        readReg(MPU60X0 self, uint8_t reg) -> uint8_t

        Parameters:
            reg: uint8_t


        uint8_t readReg(uint8_t
        reg)

        read a register

        Parameters:
        -----------

        reg:  the register to read

        the value of the register 
        """
        return _pyupm_mpu9150.MPU60X0_readReg(self, *args)

    def readRegs(self, *args):
        """
        readRegs(MPU60X0 self, uint8_t reg, uint8_t * buffer, int len)

        Parameters:
            reg: uint8_t
            buffer: uint8_t *
            len: int


        void readRegs(uint8_t
        reg, uint8_t *buffer, int len)

        read contiguous refister into a buffer

        Parameters:
        -----------

        reg:  the register to start reading at

        buffer:  the buffer to store the results

        len:  the number of registers to read

        the value of the register 
        """
        return _pyupm_mpu9150.MPU60X0_readRegs(self, *args)

    def writeReg(self, *args):
        """
        writeReg(MPU60X0 self, uint8_t reg, uint8_t val) -> bool

        Parameters:
            reg: uint8_t
            val: uint8_t


        bool writeReg(uint8_t
        reg, uint8_t val)

        write to a register

        Parameters:
        -----------

        reg:  the register to write to

        val:  the value to write

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_writeReg(self, *args)

    def setSleep(self, *args):
        """
        setSleep(MPU60X0 self, bool enable) -> bool

        Parameters:
            enable: bool


        bool setSleep(bool
        enable)

        enable or disable device sleep

        Parameters:
        -----------

        enable:  true to put device to sleep, false to wake up

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setSleep(self, *args)

    def setClockSource(self, *args):
        """
        setClockSource(MPU60X0 self, upm::MPU60X0::CLKSEL_T clk) -> bool

        Parameters:
            clk: enum upm::MPU60X0::CLKSEL_T


        bool
        setClockSource(CLKSEL_T clk)

        specify the clock source for the device to use

        Parameters:
        -----------

        clk:  one of the CLKSEL_T values

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setClockSource(self, *args)

    def setGyroscopeScale(self, *args):
        """
        setGyroscopeScale(MPU60X0 self, upm::MPU60X0::FS_SEL_T scale) -> bool

        Parameters:
            scale: enum upm::MPU60X0::FS_SEL_T


        bool
        setGyroscopeScale(FS_SEL_T scale)

        set the scaling mode of the gyroscope

        Parameters:
        -----------

        scale:  one of the FS_SEL_T values

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setGyroscopeScale(self, *args)

    def setAccelerometerScale(self, *args):
        """
        setAccelerometerScale(MPU60X0 self, upm::MPU60X0::AFS_SEL_T scale) -> bool

        Parameters:
            scale: enum upm::MPU60X0::AFS_SEL_T


        bool
        setAccelerometerScale(AFS_SEL_T scale)

        set the scaling mode of the accelerometer

        Parameters:
        -----------

        scale:  one of the AFS_SEL_T values

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setAccelerometerScale(self, *args)

    def setDigitalLowPassFilter(self, *args):
        """
        setDigitalLowPassFilter(MPU60X0 self, upm::MPU60X0::DLPF_CFG_T dlp) -> bool

        Parameters:
            dlp: enum upm::MPU60X0::DLPF_CFG_T


        bool
        setDigitalLowPassFilter(DLPF_CFG_T dlp)

        set the Low Pass Digital filter. This enables filtering (if non-0) of
        the accelerometer and gyro outputs.

        Parameters:
        -----------

        scale:  one of the DLPF_CFG_T values

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setDigitalLowPassFilter(self, *args)

    def setSampleRateDivider(self, *args):
        """
        setSampleRateDivider(MPU60X0 self, uint8_t div) -> bool

        Parameters:
            div: uint8_t


        bool
        setSampleRateDivider(uint8_t div)

        set the sample rate divider. This register specifies the divider from
        the gyro output rate used to generate the Sample Rate. The sensor
        registor output, FIFO output, DMP sampling and motion detection are
        all based on the Sample Rate.

        The Sample Rate is generated by dividing the gyro output rate by this
        register:

        Sample Rate = Gyro output rate / (1 + sample rate divider).

        The Gyro output rate is 8Khz when the Digital Low Pass Filter (DLPF)
        is 0 or 7 (DLPF_260_256 or DLPF_RESERVED), and 1Khz otherwise.

        Parameters:
        -----------

        scale:  one of the DLPF_CFG_T values

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setSampleRateDivider(self, *args)

    def getSampleRateDivider(self):
        """
        getSampleRateDivider(MPU60X0 self) -> uint8_t

        Parameters:
            self: upm::MPU60X0 *


        uint8_t
        getSampleRateDivider()

        get the current Sample Rate divider

        the current sample rate divider 
        """
        return _pyupm_mpu9150.MPU60X0_getSampleRateDivider(self)

    def getAccelerometer(self, *args):
        """
        getAccelerometer(MPU60X0 self, float * x, float * y, float * z)

        Parameters:
            x: float *
            y: float *
            z: float *


        void
        getAccelerometer(float *x, float *y, float *z)

        get the accelerometer values

        Parameters:
        -----------

        x:  the returned x value, if arg is non-NULL

        y:  the returned y value, if arg is non-NULL

        z:  the returned z value, if arg is non-NULL

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_getAccelerometer(self, *args)

    def getGyroscope(self, *args):
        """
        getGyroscope(MPU60X0 self, float * x, float * y, float * z)

        Parameters:
            x: float *
            y: float *
            z: float *


        void
        getGyroscope(float *x, float *y, float *z)

        get the gyroscope values

        Parameters:
        -----------

        x:  the returned x value, if arg is non-NULL

        y:  the returned y value, if arg is non-NULL

        z:  the returned z value, if arg is non-NULL

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_getGyroscope(self, *args)

    def getTemperature(self):
        """
        getTemperature(MPU60X0 self) -> float

        Parameters:
            self: upm::MPU60X0 *


        float
        getTemperature()

        get the temperature value

        the temperature value in degrees Celcius 
        """
        return _pyupm_mpu9150.MPU60X0_getTemperature(self)

    def enableTemperatureSensor(self, *args):
        """
        enableTemperatureSensor(MPU60X0 self, bool enable) -> bool

        Parameters:
            enable: bool


        bool
        enableTemperatureSensor(bool enable)

        enable onboard temperature measurement sensor

        Parameters:
        -----------

        enable:  true to enable temperature sensor, false to disable

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_enableTemperatureSensor(self, *args)

    def setExternalSync(self, *args):
        """
        setExternalSync(MPU60X0 self, upm::MPU60X0::EXT_SYNC_SET_T val) -> bool

        Parameters:
            val: enum upm::MPU60X0::EXT_SYNC_SET_T


        bool
        setExternalSync(EXT_SYNC_SET_T val)

        configure external sync. An external signal connected to the FSYNC pin
        can be sampled by configuring EXT_SYNC_SET. Signal changes to the
        FSYNC pin are latched so that short strobes may be captured. The
        latched FSYNC signal will be sampled at the Sampling Rate, as defined
        in register 25. After sampling, the latch will reset to the current
        FSYNC signal state.

        The sampled value will be reported in place of the least significant
        bit in a sensor data register determined by the value of EXT_SYNC_SET

        Parameters:
        -----------

        val:  one of the EXT_SYNC_SET_T values

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setExternalSync(self, *args)

    def enableI2CBypass(self, *args):
        """
        enableI2CBypass(MPU60X0 self, bool enable) -> bool

        Parameters:
            enable: bool


        bool
        enableI2CBypass(bool enable)

        enable I2C Bypass. Enabling this feature allows devices on the MPU60X0
        auxillary I2C bus to be visible on the MCU's I2C bus.

        Parameters:
        -----------

        enable:  true to I2C bypass

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_enableI2CBypass(self, *args)

    def setMotionDetectionThreshold(self, *args):
        """
        setMotionDetectionThreshold(MPU60X0 self, uint8_t thr) -> bool

        Parameters:
            thr: uint8_t


        bool setMotionDetectionThreshold(uint8_t thr)

        set the motion detection threshold for interrupt generation. Motion is
        detected when the absolute value of any of the accelerometer
        measurements exceeds this Motion detection threshold.

        Parameters:
        -----------

        thr:  threshold

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setMotionDetectionThreshold(self, *args)

    def getInterruptStatus(self):
        """
        getInterruptStatus(MPU60X0 self) -> uint8_t

        Parameters:
            self: upm::MPU60X0 *


        uint8_t
        getInterruptStatus()

        return the interrupt status register.

        the interrupt status word (see INT_STATUS_BITS_T) 
        """
        return _pyupm_mpu9150.MPU60X0_getInterruptStatus(self)

    def setInterruptEnables(self, *args):
        """
        setInterruptEnables(MPU60X0 self, uint8_t enables) -> bool

        Parameters:
            enables: uint8_t


        bool
        setInterruptEnables(uint8_t enables)

        set the interrupt enables

        Parameters:
        -----------

        enables:  bitmask of INT_ENABLE_BITS_T values to enable

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setInterruptEnables(self, *args)

    def getInterruptEnables(self):
        """
        getInterruptEnables(MPU60X0 self) -> uint8_t

        Parameters:
            self: upm::MPU60X0 *


        uint8_t
        getInterruptEnables()

        get the current interrupt enables register

        bitmask of INT_ENABLE_BITS_T values 
        """
        return _pyupm_mpu9150.MPU60X0_getInterruptEnables(self)

    def setInterruptPinConfig(self, *args):
        """
        setInterruptPinConfig(MPU60X0 self, uint8_t cfg) -> bool

        Parameters:
            cfg: uint8_t


        bool
        setInterruptPinConfig(uint8_t cfg)

        set the interrupt pin configuration

        Parameters:
        -----------

        cfg:  bitmask of INT_PIN_CFG_BITS_T values

        true if successful, false otherwise 
        """
        return _pyupm_mpu9150.MPU60X0_setInterruptPinConfig(self, *args)

    def getInterruptPinConfig(self):
        """
        getInterruptPinConfig(MPU60X0 self) -> uint8_t

        Parameters:
            self: upm::MPU60X0 *


        uint8_t
        getInterruptPinConfig()

        get the current interrupt pin configuration

        bitmask of INT_PIN_CFG_BITS_T values 
        """
        return _pyupm_mpu9150.MPU60X0_getInterruptPinConfig(self)

    def installISR(self, *args):
        """
        installISR(MPU60X0 self, int gpio, mraa::Edge level, void (*)(void *) isr, void * arg)

        Parameters:
            gpio: int
            level: mraa::Edge
            isr: void (*)(void *)
            arg: void *


        void installISR(int
        gpio, mraa::Edge level, void(*isr)(void *), void *arg)

        install an interrupt handler.

        Parameters:
        -----------

        gpio:  gpio pin to use as interrupt pin

        level:  the interrupt trigger level (one of mraa::Edge values). Make
        sure that you have configured the interrupt pin (
        setInterruptPinConfig()) properly for whatever level you choose.

        isr:  the interrupt handler, accepting a void * argument

        arg:  the argument to pass the the interrupt handler 
        """
        return _pyupm_mpu9150.MPU60X0_installISR(self, *args)

    def uninstallISR(self):
        """
        uninstallISR(MPU60X0 self)

        Parameters:
            self: upm::MPU60X0 *


        void
        uninstallISR()

        uninstall a previously installed interrupt handler 
        """
        return _pyupm_mpu9150.MPU60X0_uninstallISR(self)

MPU60X0_swigregister = _pyupm_mpu9150.MPU60X0_swigregister
MPU60X0_swigregister(MPU60X0)

MPU9150_I2C_BUS = _pyupm_mpu9150.MPU9150_I2C_BUS
MPU9150_DEFAULT_I2C_ADDR = _pyupm_mpu9150.MPU9150_DEFAULT_I2C_ADDR
class MPU9150(MPU60X0):
    """
    API for MPU9150 chip (Accelerometer, Gyro and Magnometer Sensor)

    ID: mpu9150

    Name: MPU9150 Inertial Measurement Unit

    Other Names: Grove IMU 9DOF

    Category: accelerometer compass

    Manufacturer: seeed

    Link:http://www.seeedstudio.com/wiki/Grove_-_IMU_9DOF_v1.0

    Connection: i2c gpio  This module defines the MPU9150 interface for
    libmpu9150

    C++ includes: mpu9150.h 
    """
    __swig_setmethods__ = {}
    for _s in [MPU60X0]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MPU9150, name, value)
    __swig_getmethods__ = {}
    for _s in [MPU60X0]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MPU9150, name)
    __repr__ = _swig_repr
    def __init__(self, bus=0, address=0x68, magAddress=0x0c, enableAk8975=True): 
        """
        __init__(upm::MPU9150 self, int bus=0, int address=0x68, int magAddress=0x0c, bool enableAk8975=True) -> MPU9150

        Parameters:
            bus: int
            address: int
            magAddress: int
            enableAk8975: bool

        __init__(upm::MPU9150 self, int bus=0, int address=0x68, int magAddress=0x0c) -> MPU9150

        Parameters:
            bus: int
            address: int
            magAddress: int

        __init__(upm::MPU9150 self, int bus=0, int address=0x68) -> MPU9150

        Parameters:
            bus: int
            address: int

        __init__(upm::MPU9150 self, int bus=0) -> MPU9150

        Parameters:
            bus: int

        __init__(upm::MPU9150 self) -> MPU9150

        MPU9150(int
        bus=MPU9150_I2C_BUS, int address=MPU9150_DEFAULT_I2C_ADDR, int
        magAddress=AK8975_DEFAULT_I2C_ADDR, bool enableAk8975=true)

        MPU9150 constructor

        Parameters:
        -----------

        bus:  I2C bus to use

        address:  The address for this device

        magAddress:  The address of the connected magnetometer

        enableAk8975:  Enables i2c bypass mode for magnetometer, default is
        true 
        """
        this = _pyupm_mpu9150.new_MPU9150(bus, address, magAddress, enableAk8975)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_mpu9150.delete_MPU9150
    __del__ = lambda self : None;
    def init(self):
        """
        init(MPU9150 self) -> bool

        Parameters:
            self: upm::MPU9150 *


        bool init()

        Set up initial values and start operation

        true if successful 
        """
        return _pyupm_mpu9150.MPU9150_init(self)

    def update(self):
        """
        update(MPU9150 self)

        Parameters:
            self: upm::MPU9150 *


        void update()

        Take a measurement and store the current sensor values internally.
        Note, these user facing registers are only updated from the internal
        device sensor values when the i2c serial traffic is 'idle'. So, if you
        are reading the values too fast, the bus may never be idle, and you
        will just end up reading the same values over and over.

        Unfortunately, it is is not clear how long 'idle' actually means, so
        if you see this behavior, reduce the rate at which you are calling
        update(). 
        """
        return _pyupm_mpu9150.MPU9150_update(self)

    def getMagnetometer(self, *args):
        """
        getMagnetometer(MPU9150 self, float * x, float * y, float * z)

        Parameters:
            x: float *
            y: float *
            z: float *


        void
        getMagnetometer(float *x, float *y, float *z)

        Return the compensated values for the x, y, and z axes. The unit of
        measurement is in micro-teslas (uT).

        Parameters:
        -----------

        x:  Pointer to returned X axis value

        y:  Pointer to returned Y axis value

        z:  Pointer to returned Z axis value 
        """
        return _pyupm_mpu9150.MPU9150_getMagnetometer(self, *args)

MPU9150_swigregister = _pyupm_mpu9150.MPU9150_swigregister
MPU9150_swigregister(MPU9150)

MPU9250_I2C_BUS = _pyupm_mpu9150.MPU9250_I2C_BUS
MPU9250_DEFAULT_I2C_ADDR = _pyupm_mpu9150.MPU9250_DEFAULT_I2C_ADDR
class MPU9250(MPU9150):
    """
    API for MPU9250 chip (Accelerometer, Gyro and Magnometer Sensor)

    ID: mpu9250

    Name: MPU9250 Inertial Measurement Unit

    Other Names: Grove IMU 9DOF V2

    Category: accelerometer compass

    Manufacturer: seeed

    Link:http://www.seeedstudio.com/wiki/Grove_-_IMU_9DOF_v2.0

    Connection: i2c gpio  This module defines the MPU9250 interface for
    libmpu9150

    C++ includes: mpu9250.h 
    """
    __swig_setmethods__ = {}
    for _s in [MPU9150]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MPU9250, name, value)
    __swig_getmethods__ = {}
    for _s in [MPU9150]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MPU9250, name)
    __repr__ = _swig_repr
    def __init__(self, bus=0, address=0x68, magAddress=0x0c, enableAk8975=True): 
        """
        __init__(upm::MPU9250 self, int bus=0, int address=0x68, int magAddress=0x0c, bool enableAk8975=True) -> MPU9250

        Parameters:
            bus: int
            address: int
            magAddress: int
            enableAk8975: bool

        __init__(upm::MPU9250 self, int bus=0, int address=0x68, int magAddress=0x0c) -> MPU9250

        Parameters:
            bus: int
            address: int
            magAddress: int

        __init__(upm::MPU9250 self, int bus=0, int address=0x68) -> MPU9250

        Parameters:
            bus: int
            address: int

        __init__(upm::MPU9250 self, int bus=0) -> MPU9250

        Parameters:
            bus: int

        __init__(upm::MPU9250 self) -> MPU9250

        MPU9250(int
        bus=MPU9250_I2C_BUS, int address=MPU9250_DEFAULT_I2C_ADDR, int
        magAddress=AK8975_DEFAULT_I2C_ADDR, bool enableAk8975=true)

        MPU9250 constructor

        Parameters:
        -----------

        bus:  I2C bus to use

        address:  The address for this device

        magAddress:  The address of the connected magnetometer

        enableAk8975:  Enables i2c bypass mode for magnetometer, default is
        true 
        """
        this = _pyupm_mpu9150.new_MPU9250(bus, address, magAddress, enableAk8975)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_mpu9150.delete_MPU9250
    __del__ = lambda self : None;
    def getTemperature(self):
        """
        getTemperature(MPU9250 self) -> float

        Parameters:
            self: upm::MPU9250 *


        float
        getTemperature()

        get the temperature value

        the temperature value in degrees Celcius 
        """
        return _pyupm_mpu9150.MPU9250_getTemperature(self)

MPU9250_swigregister = _pyupm_mpu9150.MPU9250_swigregister
MPU9250_swigregister(MPU9250)

# This file is compatible with both classic and new-style classes.


