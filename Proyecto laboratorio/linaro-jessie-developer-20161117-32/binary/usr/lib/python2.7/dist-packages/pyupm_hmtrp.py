# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_hmtrp', [dirname(__file__)])
        except ImportError:
            import _pyupm_hmtrp
            return _pyupm_hmtrp
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_hmtrp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_hmtrp = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_hmtrp
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class uint8Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint8Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint8Array, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pyupm_hmtrp.new_uint8Array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_hmtrp.delete_uint8Array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _pyupm_hmtrp.uint8Array___getitem__(self, *args)
    def __setitem__(self, *args): return _pyupm_hmtrp.uint8Array___setitem__(self, *args)
    def cast(self): return _pyupm_hmtrp.uint8Array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _pyupm_hmtrp.uint8Array_frompointer
    if _newclass:frompointer = staticmethod(_pyupm_hmtrp.uint8Array_frompointer)
uint8Array_swigregister = _pyupm_hmtrp.uint8Array_swigregister
uint8Array_swigregister(uint8Array)

def uint8Array_frompointer(*args):
  return _pyupm_hmtrp.uint8Array_frompointer(*args)
uint8Array_frompointer = _pyupm_hmtrp.uint8Array_frompointer

class uint16Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint16Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint16Array, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pyupm_hmtrp.new_uint16Array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_hmtrp.delete_uint16Array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _pyupm_hmtrp.uint16Array___getitem__(self, *args)
    def __setitem__(self, *args): return _pyupm_hmtrp.uint16Array___setitem__(self, *args)
    def cast(self): return _pyupm_hmtrp.uint16Array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _pyupm_hmtrp.uint16Array_frompointer
    if _newclass:frompointer = staticmethod(_pyupm_hmtrp.uint16Array_frompointer)
uint16Array_swigregister = _pyupm_hmtrp.uint16Array_swigregister
uint16Array_swigregister(uint16Array)

def uint16Array_frompointer(*args):
  return _pyupm_hmtrp.uint16Array_frompointer(*args)
uint16Array_frompointer = _pyupm_hmtrp.uint16Array_frompointer

class uint32Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint32Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint32Array, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pyupm_hmtrp.new_uint32Array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_hmtrp.delete_uint32Array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _pyupm_hmtrp.uint32Array___getitem__(self, *args)
    def __setitem__(self, *args): return _pyupm_hmtrp.uint32Array___setitem__(self, *args)
    def cast(self): return _pyupm_hmtrp.uint32Array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _pyupm_hmtrp.uint32Array_frompointer
    if _newclass:frompointer = staticmethod(_pyupm_hmtrp.uint32Array_frompointer)
uint32Array_swigregister = _pyupm_hmtrp.uint32Array_swigregister
uint32Array_swigregister(uint32Array)

def uint32Array_frompointer(*args):
  return _pyupm_hmtrp.uint32Array_frompointer(*args)
uint32Array_frompointer = _pyupm_hmtrp.uint32Array_frompointer

HMTRP_DEFAULT_UART = _pyupm_hmtrp.HMTRP_DEFAULT_UART
class HMTRP(_object):
    """
    API for the HM-TRP Serial RF Pro transceiver.

    ID: hmtrp

    Name: Grove Serial RF Pro

    Other Names: HMTRP-433 HMTRP-470 HMTRP-868 HMTRP-915

    Category: wifi

    Manufacturer: seeed

    Connection: uart  UPM support for the HM-TRP Serial RF Pro
    transceiver. This was tested specifically with the Grove Serial RF Pro
    transceiver. In theory, this class should work with the following
    devices:

    HM-TRP-433: 414000000-454000000Hz HM-TRP-470: 450000000-490000000Hz
    HM-TRP-868: 849000000-889000000Hz HM-TRP-915: 895000000-935000000Hz

    The only difference is the transmit and receive frequencies supported.

    By default, the device simply sends and receives any data presented on
    its UART interface. It can be put into a configuration mode by
    grounding the CONFIG pin on the transceiver.

    C++ includes: hmtrp.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMTRP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HMTRP, name)
    __repr__ = _swig_repr
    RESET = _pyupm_hmtrp.HMTRP_RESET
    GET_CONFIG = _pyupm_hmtrp.HMTRP_GET_CONFIG
    SET_FREQUENCY = _pyupm_hmtrp.HMTRP_SET_FREQUENCY
    SET_RF_DATARATE = _pyupm_hmtrp.HMTRP_SET_RF_DATARATE
    SET_RX_BW = _pyupm_hmtrp.HMTRP_SET_RX_BW
    SET_FREQ_MODULATION = _pyupm_hmtrp.HMTRP_SET_FREQ_MODULATION
    SET_TX_POWER = _pyupm_hmtrp.HMTRP_SET_TX_POWER
    SET_UART_SPEED = _pyupm_hmtrp.HMTRP_SET_UART_SPEED
    GET_RF_SIGNAL_STR = _pyupm_hmtrp.HMTRP_GET_RF_SIGNAL_STR
    GET_MOD_SIGNAL_STR = _pyupm_hmtrp.HMTRP_GET_MOD_SIGNAL_STR
    def __init__(self, uart=0): 
        """
        __init__(upm::HMTRP self, int uart=0) -> HMTRP

        Parameters:
            uart: int

        __init__(upm::HMTRP self) -> HMTRP

        HMTRP(int
        uart=HMTRP_DEFAULT_UART)

        HMTRP Serial RF Pro transceiver constructor

        Parameters:
        -----------

        uart:  Default UART to use (0 or 1) 
        """
        this = _pyupm_hmtrp.new_HMTRP(uart)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_hmtrp.delete_HMTRP
    __del__ = lambda self : None;
    def dataAvailable(self, millis=0):
        """
        dataAvailable(HMTRP self, unsigned int millis=0) -> bool

        Parameters:
            millis: unsigned int

        dataAvailable(HMTRP self) -> bool

        Parameters:
            self: upm::HMTRP *


        bool
        dataAvailable(unsigned int millis=0)

        Checks to see if there is data available for reading

        Parameters:
        -----------

        millis:  Number of milliseconds to wait; 0 means no waiting (default).

        True if there is data available for reading 
        """
        return _pyupm_hmtrp.HMTRP_dataAvailable(self, millis)

    def readData(self, *args):
        """
        readData(HMTRP self, char * buffer, int len, int millis=-1) -> int

        Parameters:
            buffer: char *
            len: int
            millis: int

        readData(HMTRP self, char * buffer, int len) -> int

        Parameters:
            buffer: char *
            len: int


        int readData(char
        *buffer, int len, int millis=-1)

        Reads any available data in a user-supplied buffer

        Parameters:
        -----------

        buffer:  Buffer to hold the data read

        len:  Length of the buffer

        millis:  Maximum time in milliseconds to wait for input. -1 means
        waiting forever (default).

        Number of bytes read; 0 if timed out and millis is >= 0 
        """
        return _pyupm_hmtrp.HMTRP_readData(self, *args)

    def writeData(self, *args):
        """
        writeData(HMTRP self, char * buffer, int len) -> int

        Parameters:
            buffer: char *
            len: int


        int writeData(char
        *buffer, int len)

        Writes the data in the buffer to the device

        Parameters:
        -----------

        buffer:  Buffer to hold the data read

        len:  Length of the buffer

        Number of bytes written 
        """
        return _pyupm_hmtrp.HMTRP_writeData(self, *args)

    def setupTty(self, *args):
        """
        setupTty(HMTRP self, speed_t baud=B9600) -> bool

        Parameters:
            baud: speed_t

        setupTty(HMTRP self) -> bool

        Parameters:
            self: upm::HMTRP *


        bool setupTty(speed_t
        baud=B9600)

        Sets up proper tty I/O modes and the baud rate. The default baud rate
        is 9,600 (B9600).

        Parameters:
        -----------

        baud:  Desired baud rate.

        True if successful 
        """
        return _pyupm_hmtrp.HMTRP_setupTty(self, *args)

    def checkOK(self):
        """
        checkOK(HMTRP self) -> bool

        Parameters:
            self: upm::HMTRP *


        bool checkOK()

        Looks for and verifies an OK response. This looks like
        "OK\\r\\n"

        True if OK received 
        """
        return _pyupm_hmtrp.HMTRP_checkOK(self)

    def reset(self):
        """
        reset(HMTRP self) -> bool

        Parameters:
            self: upm::HMTRP *


        bool reset()

        Resets the device to default parameters, except for the UART baud rate

        True if successful 
        """
        return _pyupm_hmtrp.HMTRP_reset(self)

    def getConfig(self, *args):
        """
        getConfig(HMTRP self, uint32_t * freq, uint32_t * dataRate, uint16_t * rxBandwidth, uint8_t * modulation, 
            uint8_t * txPower, uint32_t * uartBaud) -> bool

        Parameters:
            freq: uint32_t *
            dataRate: uint32_t *
            rxBandwidth: uint16_t *
            modulation: uint8_t *
            txPower: uint8_t *
            uartBaud: uint32_t *


        bool getConfig(uint32_t
        *freq, uint32_t *dataRate, uint16_t *rxBandwidth, uint8_t *modulation,
        uint8_t *txPower, uint32_t *uartBaud)

        Queries the radio to determine its configuration

        Parameters:
        -----------

        freq:  Operating frequency

        dataRate:  TX/RX bit rate

        rxBandwidth:  Receiving bandwidth in Khz

        modulation:  Modulation frequency in Khz

        txPower:  Transmission power (1-7)

        uartBaud:  UART baud rate

        True if successful 
        """
        return _pyupm_hmtrp.HMTRP_getConfig(self, *args)

    def setFrequency(self, *args):
        """
        setFrequency(HMTRP self, uint32_t freq) -> bool

        Parameters:
            freq: uint32_t


        bool
        setFrequency(uint32_t freq)

        Sets the frequency. Note: this is limited depending on which HM-TRP
        device you are using. Consult the datasheet.

        Parameters:
        -----------

        freq:  Operating frequency

        True if successful 
        """
        return _pyupm_hmtrp.HMTRP_setFrequency(self, *args)

    def setRFDataRate(self, *args):
        """
        setRFDataRate(HMTRP self, uint32_t rate) -> bool

        Parameters:
            rate: uint32_t


        bool
        setRFDataRate(uint32_t rate)

        Sets the RF data transmission rate. Valid values are between 1,200 and
        115,200.

        Parameters:
        -----------

        rate:  Radio transmission rate in baud (1,200-115,200)

        True if successful 
        """
        return _pyupm_hmtrp.HMTRP_setRFDataRate(self, *args)

    def setRXBandwidth(self, *args):
        """
        setRXBandwidth(HMTRP self, uint16_t rxBand) -> bool

        Parameters:
            rxBand: uint16_t


        bool
        setRXBandwidth(uint16_t rxBand)

        Sets the RX bandwidth. Valid values are between 30 and 620 (in Khz)

        Parameters:
        -----------

        rxBand:  RX bandwidth in Khz (30-620)

        True if successful 
        """
        return _pyupm_hmtrp.HMTRP_setRXBandwidth(self, *args)

    def setFrequencyModulation(self, *args):
        """
        setFrequencyModulation(HMTRP self, uint8_t modulation) -> bool

        Parameters:
            modulation: uint8_t


        bool
        setFrequencyModulation(uint8_t modulation)

        Sets the frequency modulation. Valid values are between 10 and 160 (in
        Khz)

        Parameters:
        -----------

        modulation:  Frequency modulation to use, in Khz (10-160)

        True if successful 
        """
        return _pyupm_hmtrp.HMTRP_setFrequencyModulation(self, *args)

    def setTransmitPower(self, *args):
        """
        setTransmitPower(HMTRP self, uint8_t power) -> bool

        Parameters:
            power: uint8_t


        bool
        setTransmitPower(uint8_t power)

        Sets the transmit power level. Valid values are between 0 and 7, 7
        being the maximum power.

        Parameters:
        -----------

        power:  Power level to use during transmission. Valid values are
        between 0 and 7.

        True if successful 
        """
        return _pyupm_hmtrp.HMTRP_setTransmitPower(self, *args)

    def setUARTSpeed(self, *args):
        """
        setUARTSpeed(HMTRP self, uint32_t speed) -> bool

        Parameters:
            speed: uint32_t


        bool
        setUARTSpeed(uint32_t speed)

        Sets the configured baud rate of the UART. It is strongly recommended
        you do not change this, or you may lose the ability to communicate
        with the transceiver. Valid values are 1,200-115,200.

        Parameters:
        -----------

        speed:  Desired baud rate to configure the device to use Valid values
        are between 1,200 and 115,200.

        True if successful 
        """
        return _pyupm_hmtrp.HMTRP_setUARTSpeed(self, *args)

    def getRFSignalStrength(self, *args):
        """
        getRFSignalStrength(HMTRP self, uint8_t * strength) -> bool

        Parameters:
            strength: uint8_t *


        uint8_t
        getRFSignalStrength()

        Gets the RF signal strength

        Signal strength

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_hmtrp.HMTRP_getRFSignalStrength(self, *args)

    def getRFSignalStrengthNoParam(self):
        """
        getRFSignalStrengthNoParam(HMTRP self) -> uint8_t

        Parameters:
            self: upm::HMTRP *


        uint8_t
        getRFSignalStrength()

        Gets the RF signal strength

        Signal strength

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_hmtrp.HMTRP_getRFSignalStrengthNoParam(self)

    def getModSignalStrength(self, *args):
        """
        getModSignalStrength(HMTRP self, uint8_t * strength) -> bool

        Parameters:
            strength: uint8_t *


        uint8_t
        getModSignalStrength()

        Gets the modulation signal strength.

        Signal strength

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_hmtrp.HMTRP_getModSignalStrength(self, *args)

    def getModSignalStrengthNoParam(self):
        """
        getModSignalStrengthNoParam(HMTRP self) -> uint8_t

        Parameters:
            self: upm::HMTRP *


        uint8_t
        getModSignalStrength()

        Gets the modulation signal strength.

        Signal strength

        Exceptions:
        -----------

        std::runtime_error:  if reading from the sensor failed 
        """
        return _pyupm_hmtrp.HMTRP_getModSignalStrengthNoParam(self)

HMTRP_swigregister = _pyupm_hmtrp.HMTRP_swigregister
HMTRP_swigregister(HMTRP)

class charArray(_object):
    """Proxy of C++ charArray class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, charArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, charArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(charArray self, size_t nelements) -> charArray

        Parameters:
            nelements: size_t

        """
        this = _pyupm_hmtrp.new_charArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_hmtrp.delete_charArray
    __del__ = lambda self : None;
    def __getitem__(self, *args):
        """
        __getitem__(charArray self, size_t index) -> char

        Parameters:
            index: size_t

        """
        return _pyupm_hmtrp.charArray___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(charArray self, size_t index, char value)

        Parameters:
            index: size_t
            value: char

        """
        return _pyupm_hmtrp.charArray___setitem__(self, *args)

    def cast(self):
        """
        cast(charArray self) -> char *

        Parameters:
            self: charArray *

        """
        return _pyupm_hmtrp.charArray_cast(self)

    def frompointer(*args):
        """
        frompointer(char * t) -> charArray

        Parameters:
            t: char *

        """
        return _pyupm_hmtrp.charArray_frompointer(*args)

    if _newclass:frompointer = staticmethod(frompointer)
    __swig_getmethods__["frompointer"] = lambda x: frompointer
charArray_swigregister = _pyupm_hmtrp.charArray_swigregister
charArray_swigregister(charArray)
cvar = _pyupm_hmtrp.cvar

def charArray_frompointer(*args):
  """
    charArray_frompointer(char * t) -> charArray

    Parameters:
        t: char *

    """
  return _pyupm_hmtrp.charArray_frompointer(*args)

# This file is compatible with both classic and new-style classes.


