# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_bma220', [dirname(__file__)])
        except ImportError:
            import _pyupm_bma220
            return _pyupm_bma220
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_bma220', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_bma220 = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_bma220
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0



def new_floatp():
  """new_floatp() -> float *"""
  return _pyupm_bma220.new_floatp()

def copy_floatp(*args):
  """
    copy_floatp(float value) -> float *

    Parameters:
        value: float

    """
  return _pyupm_bma220.copy_floatp(*args)

def delete_floatp(*args):
  """
    delete_floatp(float * obj)

    Parameters:
        obj: float *

    """
  return _pyupm_bma220.delete_floatp(*args)

def floatp_assign(*args):
  """
    floatp_assign(float * obj, float value)

    Parameters:
        obj: float *
        value: float

    """
  return _pyupm_bma220.floatp_assign(*args)

def floatp_value(*args):
  """
    floatp_value(float * obj) -> float

    Parameters:
        obj: float *

    """
  return _pyupm_bma220.floatp_value(*args)
BMA220_I2C_BUS = _pyupm_bma220.BMA220_I2C_BUS
BMA220_DEFAULT_ADDR = _pyupm_bma220.BMA220_DEFAULT_ADDR
class BMA220(_object):
    """
    API for the BMA220 3-axis Accelerometer.

    ID: bma220

    Name: BMA220 3-axis Accelerometer

    Category: accelerometer

    Manufacturer: dfrobot

    Connection: i2c gpio

    Link:http://www.dfrobot.com/index.php?route=product/product&product_id=1085
    The BMA220 is a low cost, very small 3-axis accelerometer with 6 bits
    of resolution. It can also detect orientation and tap events.

    The BMA220 has a linear acceleration full scale of 2g/4g/8g/16g.

    While not all of the functionality of this device is supported
    initially, methods and register definitions are provided that should
    allow an end user to implement whatever features are required.

    This driver was developed on a DFRobot BMA (Tiny).

    C++ includes: bma220.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BMA220, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BMA220, name)
    __repr__ = _swig_repr
    REG_CHIPID = _pyupm_bma220.BMA220_REG_CHIPID
    REG_REVISIONID = _pyupm_bma220.BMA220_REG_REVISIONID
    REG_ACC_X = _pyupm_bma220.BMA220_REG_ACC_X
    REG_ACC_Y = _pyupm_bma220.BMA220_REG_ACC_Y
    REG_ACC_Z = _pyupm_bma220.BMA220_REG_ACC_Z
    REG_H_HYST_DUR = _pyupm_bma220.BMA220_REG_H_HYST_DUR
    REG_THRESHOLD = _pyupm_bma220.BMA220_REG_THRESHOLD
    REG_L_HYST_DUR = _pyupm_bma220.BMA220_REG_L_HYST_DUR
    REG_TAP_CONFIG = _pyupm_bma220.BMA220_REG_TAP_CONFIG
    REG_SLOPE_CONFIG = _pyupm_bma220.BMA220_REG_SLOPE_CONFIG
    REG_TAP_CONFIG2 = _pyupm_bma220.BMA220_REG_TAP_CONFIG2
    REG_INT_STATUS1 = _pyupm_bma220.BMA220_REG_INT_STATUS1
    REG_INT_STATUS2 = _pyupm_bma220.BMA220_REG_INT_STATUS2
    REG_ENABLE_CONFIG = _pyupm_bma220.BMA220_REG_ENABLE_CONFIG
    REG_ENABLE_CONFIG2 = _pyupm_bma220.BMA220_REG_ENABLE_CONFIG2
    REG_ENABLE_CONFIG3 = _pyupm_bma220.BMA220_REG_ENABLE_CONFIG3
    REG_FILTER_CONFIG = _pyupm_bma220.BMA220_REG_FILTER_CONFIG
    REG_SBIST_FSL_CONFIG = _pyupm_bma220.BMA220_REG_SBIST_FSL_CONFIG
    REG_I2C_WATCHDOG = _pyupm_bma220.BMA220_REG_I2C_WATCHDOG
    REG_SUSPEND = _pyupm_bma220.BMA220_REG_SUSPEND
    REG_SOFTRESET = _pyupm_bma220.BMA220_REG_SOFTRESET
    H_HYST_DUR_HIGH_DUR0 = _pyupm_bma220.BMA220_H_HYST_DUR_HIGH_DUR0
    H_HYST_DUR_HIGH_DUR1 = _pyupm_bma220.BMA220_H_HYST_DUR_HIGH_DUR1
    H_HYST_DUR_HIGH_DUR2 = _pyupm_bma220.BMA220_H_HYST_DUR_HIGH_DUR2
    H_HYST_DUR_HIGH_DUR3 = _pyupm_bma220.BMA220_H_HYST_DUR_HIGH_DUR3
    H_HYST_DUR_HIGH_DUR4 = _pyupm_bma220.BMA220_H_HYST_DUR_HIGH_DUR4
    H_HYST_DUR_HIGH_DUR5 = _pyupm_bma220.BMA220_H_HYST_DUR_HIGH_DUR5
    _H_HYST_DUR_HIGH_DUR_MASK = _pyupm_bma220.BMA220__H_HYST_DUR_HIGH_DUR_MASK
    _H_HYST_DUR_HIGH_DUR_SHIFT = _pyupm_bma220.BMA220__H_HYST_DUR_HIGH_DUR_SHIFT
    H_HYST_DUR_HIGH_HY1 = _pyupm_bma220.BMA220_H_HYST_DUR_HIGH_HY1
    H_HYST_DUR_HIGH_HY2 = _pyupm_bma220.BMA220_H_HYST_DUR_HIGH_HY2
    _H_HYST_DUR_HIGH_HY_MASK = _pyupm_bma220.BMA220__H_HYST_DUR_HIGH_HY_MASK
    _H_HYST_DUR_HIGH_HY_SHIFT = _pyupm_bma220.BMA220__H_HYST_DUR_HIGH_HY_SHIFT
    THRESHOLD_HIGH0 = _pyupm_bma220.BMA220_THRESHOLD_HIGH0
    THRESHOLD_HIGH1 = _pyupm_bma220.BMA220_THRESHOLD_HIGH1
    THRESHOLD_HIGH2 = _pyupm_bma220.BMA220_THRESHOLD_HIGH2
    THRESHOLD_HIGH3 = _pyupm_bma220.BMA220_THRESHOLD_HIGH3
    _THRESHOLD_HIGH_MASK = _pyupm_bma220.BMA220__THRESHOLD_HIGH_MASK
    _THRESHOLD_HIGH_SHIFT = _pyupm_bma220.BMA220__THRESHOLD_HIGH_SHIFT
    THRESHOLD_LOW0 = _pyupm_bma220.BMA220_THRESHOLD_LOW0
    THRESHOLD_LOW1 = _pyupm_bma220.BMA220_THRESHOLD_LOW1
    THRESHOLD_LOW2 = _pyupm_bma220.BMA220_THRESHOLD_LOW2
    THRESHOLD_LOW3 = _pyupm_bma220.BMA220_THRESHOLD_LOW3
    _THRESHOLD_LOW_MASK = _pyupm_bma220.BMA220__THRESHOLD_LOW_MASK
    _THRESHOLD_LOW_SHIFT = _pyupm_bma220.BMA220__THRESHOLD_LOW_SHIFT
    L_HYST_DUR_LOW_DUR0 = _pyupm_bma220.BMA220_L_HYST_DUR_LOW_DUR0
    L_HYST_DUR_LOW_DUR1 = _pyupm_bma220.BMA220_L_HYST_DUR_LOW_DUR1
    L_HYST_DUR_LOW_DUR2 = _pyupm_bma220.BMA220_L_HYST_DUR_LOW_DUR2
    L_HYST_DUR_LOW_DUR3 = _pyupm_bma220.BMA220_L_HYST_DUR_LOW_DUR3
    L_HYST_DUR_LOW_DUR4 = _pyupm_bma220.BMA220_L_HYST_DUR_LOW_DUR4
    L_HYST_DUR_LOW_DUR5 = _pyupm_bma220.BMA220_L_HYST_DUR_LOW_DUR5
    _L_HYST_DUR_LOW_DUR_MASK = _pyupm_bma220.BMA220__L_HYST_DUR_LOW_DUR_MASK
    _L_HYST_DUR_LOW_DUR_SHIFT = _pyupm_bma220.BMA220__L_HYST_DUR_LOW_DUR_SHIFT
    L_HYST_DUR_LOW_HY1 = _pyupm_bma220.BMA220_L_HYST_DUR_LOW_HY1
    L_HYST_DUR_LOW_HY2 = _pyupm_bma220.BMA220_L_HYST_DUR_LOW_HY2
    _L_HYST_DUR_LOW_HY_MASK = _pyupm_bma220.BMA220__L_HYST_DUR_LOW_HY_MASK
    _L_HYST_DUR_LOW_HY_SHIFT = _pyupm_bma220.BMA220__L_HYST_DUR_LOW_HY_SHIFT
    TAP_CONFIG_DUR0 = _pyupm_bma220.BMA220_TAP_CONFIG_DUR0
    TAP_CONFIG_DUR1 = _pyupm_bma220.BMA220_TAP_CONFIG_DUR1
    TAP_CONFIG_DUR2 = _pyupm_bma220.BMA220_TAP_CONFIG_DUR2
    _TAP_CONFIG_DUR_MASK = _pyupm_bma220.BMA220__TAP_CONFIG_DUR_MASK
    _TAP_CONFIG_DUR_SHIFT = _pyupm_bma220.BMA220__TAP_CONFIG_DUR_SHIFT
    TAP_CONFIG_THRESH0 = _pyupm_bma220.BMA220_TAP_CONFIG_THRESH0
    TAP_CONFIG_THRESH1 = _pyupm_bma220.BMA220_TAP_CONFIG_THRESH1
    TAP_CONFIG_THRESH2 = _pyupm_bma220.BMA220_TAP_CONFIG_THRESH2
    TAP_CONFIG_THRESH3 = _pyupm_bma220.BMA220_TAP_CONFIG_THRESH3
    _TAP_CONFIG_THRESH_MASK = _pyupm_bma220.BMA220__TAP_CONFIG_THRESH_MASK
    _TAP_CONFIG_THRESH_SHIFT = _pyupm_bma220.BMA220__TAP_CONFIG_THRESH_SHIFT
    TAP_CONFIG_FILTER = _pyupm_bma220.BMA220_TAP_CONFIG_FILTER
    SLOPE_CONFIG_DUR0 = _pyupm_bma220.BMA220_SLOPE_CONFIG_DUR0
    SLOPE_CONFIG_DUR1 = _pyupm_bma220.BMA220_SLOPE_CONFIG_DUR1
    _SLOPE_CONFIG_DUR_MASK = _pyupm_bma220.BMA220__SLOPE_CONFIG_DUR_MASK
    _SLOPE_CONFIG_DUR_SHIFT = _pyupm_bma220.BMA220__SLOPE_CONFIG_DUR_SHIFT
    SLOPE_CONFIG_THRESH0 = _pyupm_bma220.BMA220_SLOPE_CONFIG_THRESH0
    SLOPE_CONFIG_THRESH1 = _pyupm_bma220.BMA220_SLOPE_CONFIG_THRESH1
    SLOPE_CONFIG_THRESH2 = _pyupm_bma220.BMA220_SLOPE_CONFIG_THRESH2
    SLOPE_CONFIG_THRESH3 = _pyupm_bma220.BMA220_SLOPE_CONFIG_THRESH3
    _SLOPE_CONFIG_THRESH_MASK = _pyupm_bma220.BMA220__SLOPE_CONFIG_THRESH_MASK
    _SLOPE_CONFIG_THRESH_SHIFT = _pyupm_bma220.BMA220__SLOPE_CONFIG_THRESH_SHIFT
    SLOPE_CONFIG_FILTER = _pyupm_bma220.BMA220_SLOPE_CONFIG_FILTER
    SLOPE_CONFIG_ORIENT_EX = _pyupm_bma220.BMA220_SLOPE_CONFIG_ORIENT_EX
    TAP_CONFIG2_SAMP0 = _pyupm_bma220.BMA220_TAP_CONFIG2_SAMP0
    TAP_CONFIG2_SAMP1 = _pyupm_bma220.BMA220_TAP_CONFIG2_SAMP1
    _TAP_CONFIG2_SAMP_MASK = _pyupm_bma220.BMA220__TAP_CONFIG2_SAMP_MASK
    _TAP_CONFIG2_SAMP_SHIFT = _pyupm_bma220.BMA220__TAP_CONFIG2_SAMP_SHIFT
    TAP_CONFIG2_ORIENT_BLOCK0 = _pyupm_bma220.BMA220_TAP_CONFIG2_ORIENT_BLOCK0
    TAP_CONFIG2_ORIENT_BLOCK1 = _pyupm_bma220.BMA220_TAP_CONFIG2_ORIENT_BLOCK1
    _TAP_CONFIG2_ORIENT_BLOCK_MASK = _pyupm_bma220.BMA220__TAP_CONFIG2_ORIENT_BLOCK_MASK
    _TAP_CONFIG2_ORIENT_BLOCK_SHIFT = _pyupm_bma220.BMA220__TAP_CONFIG2_ORIENT_BLOCK_SHIFT
    TAP_CONFIG2_TIP_EN = _pyupm_bma220.BMA220_TAP_CONFIG2_TIP_EN
    TAP_SAMP_2 = _pyupm_bma220.BMA220_TAP_SAMP_2
    TAP_SAMP_4 = _pyupm_bma220.BMA220_TAP_SAMP_4
    TAP_SAMP_8 = _pyupm_bma220.BMA220_TAP_SAMP_8
    TAP_SAMP_16 = _pyupm_bma220.BMA220_TAP_SAMP_16
    TAP_ORIENT_BLOCK_0 = _pyupm_bma220.BMA220_TAP_ORIENT_BLOCK_0
    TAP_ORIENT_BLOCK_2 = _pyupm_bma220.BMA220_TAP_ORIENT_BLOCK_2
    TAP_ORIENT_BLOCK_3 = _pyupm_bma220.BMA220_TAP_ORIENT_BLOCK_3
    TAP_ORIENT_BLOCK_4 = _pyupm_bma220.BMA220_TAP_ORIENT_BLOCK_4
    INT_STATUS1_SIGN = _pyupm_bma220.BMA220_INT_STATUS1_SIGN
    INT_STATUS1_FIRST_Z = _pyupm_bma220.BMA220_INT_STATUS1_FIRST_Z
    INT_STATUS1_FIRST_Y = _pyupm_bma220.BMA220_INT_STATUS1_FIRST_Y
    INT_STATUS1_FIRST_X = _pyupm_bma220.BMA220_INT_STATUS1_FIRST_X
    INT_STATUS1_ORIENT0 = _pyupm_bma220.BMA220_INT_STATUS1_ORIENT0
    INT_STATUS1_ORIENT1 = _pyupm_bma220.BMA220_INT_STATUS1_ORIENT1
    INT_STATUS1_ORIENT2 = _pyupm_bma220.BMA220_INT_STATUS1_ORIENT2
    _INT_STATUS1_ORIENT_MASK = _pyupm_bma220.BMA220__INT_STATUS1_ORIENT_MASK
    _INT_STATUS1_ORIENT_SHIFT = _pyupm_bma220.BMA220__INT_STATUS1_ORIENT_SHIFT
    INT_STATUS1_ORIENT_INT = _pyupm_bma220.BMA220_INT_STATUS1_ORIENT_INT
    CONFIG_ORI_UP_PORT_UPRIGHT = _pyupm_bma220.BMA220_CONFIG_ORI_UP_PORT_UPRIGHT
    CONFIG_ORI_UP_PORT_UPSIDE_DOWN = _pyupm_bma220.BMA220_CONFIG_ORI_UP_PORT_UPSIDE_DOWN
    CONFIG_ORI_UP_LAND_LEFT = _pyupm_bma220.BMA220_CONFIG_ORI_UP_LAND_LEFT
    CONFIG_ORI_UP_LAND_RIGHT = _pyupm_bma220.BMA220_CONFIG_ORI_UP_LAND_RIGHT
    CONFIG_ORI_DN_PORT_UPRIGHT = _pyupm_bma220.BMA220_CONFIG_ORI_DN_PORT_UPRIGHT
    CONFIG_ORI_DN_PORT_UPSIDE_DOWN = _pyupm_bma220.BMA220_CONFIG_ORI_DN_PORT_UPSIDE_DOWN
    CONFIG_ORI_DN_LAND_LEFT = _pyupm_bma220.BMA220_CONFIG_ORI_DN_LAND_LEFT
    CONFIG_ORI_DN_LAND_RIGHT = _pyupm_bma220.BMA220_CONFIG_ORI_DN_LAND_RIGHT
    INT_STATUS2_SLOPE = _pyupm_bma220.BMA220_INT_STATUS2_SLOPE
    INT_STATUS2_DATA = _pyupm_bma220.BMA220_INT_STATUS2_DATA
    INT_STATUS2_HIGH = _pyupm_bma220.BMA220_INT_STATUS2_HIGH
    INT_STATUS2_LOW = _pyupm_bma220.BMA220_INT_STATUS2_LOW
    INT_STATUS2_TAP = _pyupm_bma220.BMA220_INT_STATUS2_TAP
    ENABLE_CONFIG_TT_Z = _pyupm_bma220.BMA220_ENABLE_CONFIG_TT_Z
    ENABLE_CONFIG_TT_Y = _pyupm_bma220.BMA220_ENABLE_CONFIG_TT_Y
    ENABLE_CONFIG_TT_X = _pyupm_bma220.BMA220_ENABLE_CONFIG_TT_X
    ENABLE_CONFIG_SLOPE_Z = _pyupm_bma220.BMA220_ENABLE_CONFIG_SLOPE_Z
    ENABLE_CONFIG_SLOPE_Y = _pyupm_bma220.BMA220_ENABLE_CONFIG_SLOPE_Y
    ENABLE_CONFIG_SLOPE_X = _pyupm_bma220.BMA220_ENABLE_CONFIG_SLOPE_X
    ENABLE_CONFIG_ORIENT = _pyupm_bma220.BMA220_ENABLE_CONFIG_ORIENT
    ENABLE_CONFIG_DATA = _pyupm_bma220.BMA220_ENABLE_CONFIG_DATA
    ENABLE_CONFIG2_HIGH_Z = _pyupm_bma220.BMA220_ENABLE_CONFIG2_HIGH_Z
    ENABLE_CONFIG2_HIGH_Y = _pyupm_bma220.BMA220_ENABLE_CONFIG2_HIGH_Y
    ENABLE_CONFIG2_HIGH_X = _pyupm_bma220.BMA220_ENABLE_CONFIG2_HIGH_X
    ENABLE_CONFIG2_LOW = _pyupm_bma220.BMA220_ENABLE_CONFIG2_LOW
    ENABLE_CONFIG2_LAT_INT0 = _pyupm_bma220.BMA220_ENABLE_CONFIG2_LAT_INT0
    ENABLE_CONFIG2_LAT_INT1 = _pyupm_bma220.BMA220_ENABLE_CONFIG2_LAT_INT1
    ENABLE_CONFIG2_LAT_INT2 = _pyupm_bma220.BMA220_ENABLE_CONFIG2_LAT_INT2
    _ENABLE_CONFIG2_LAT_INT_MASK = _pyupm_bma220.BMA220__ENABLE_CONFIG2_LAT_INT_MASK
    _ENABLE_CONFIG2_LAT_INT_SHIFT = _pyupm_bma220.BMA220__ENABLE_CONFIG2_LAT_INT_SHIFT
    ENABLE_CONFIG2_RESET_INT = _pyupm_bma220.BMA220_ENABLE_CONFIG2_RESET_INT
    CONFIG2_LAT_UNLATCH = _pyupm_bma220.BMA220_CONFIG2_LAT_UNLATCH
    CONFIG2_LAT_0_25 = _pyupm_bma220.BMA220_CONFIG2_LAT_0_25
    CONFIG2_LAT_0_5 = _pyupm_bma220.BMA220_CONFIG2_LAT_0_5
    CONFIG2_LAT_1 = _pyupm_bma220.BMA220_CONFIG2_LAT_1
    CONFIG2_LAT_2 = _pyupm_bma220.BMA220_CONFIG2_LAT_2
    CONFIG2_LAT_4 = _pyupm_bma220.BMA220_CONFIG2_LAT_4
    CONFIG2_LAT_8 = _pyupm_bma220.BMA220_CONFIG2_LAT_8
    CONFIG2_LAT_PERM = _pyupm_bma220.BMA220_CONFIG2_LAT_PERM
    ENABLE_CONFIG3_Z_CHAN = _pyupm_bma220.BMA220_ENABLE_CONFIG3_Z_CHAN
    ENABLE_CONFIG3_Y_CHAN = _pyupm_bma220.BMA220_ENABLE_CONFIG3_Y_CHAN
    ENABLE_CONFIG3_X_CHAN = _pyupm_bma220.BMA220_ENABLE_CONFIG3_X_CHAN
    ENABLE_CONFIG3_SLEEP_DUR0 = _pyupm_bma220.BMA220_ENABLE_CONFIG3_SLEEP_DUR0
    ENABLE_CONFIG3_SLEEP_DUR1 = _pyupm_bma220.BMA220_ENABLE_CONFIG3_SLEEP_DUR1
    ENABLE_CONFIG3_SLEEP_DUR2 = _pyupm_bma220.BMA220_ENABLE_CONFIG3_SLEEP_DUR2
    _ENABLE_CONFIG3_SLEEP_DUR_MASK = _pyupm_bma220.BMA220__ENABLE_CONFIG3_SLEEP_DUR_MASK
    _ENABLE_CONFIG3_SLEEP_DUR_SHIFT = _pyupm_bma220.BMA220__ENABLE_CONFIG3_SLEEP_DUR_SHIFT
    ENABLE_CONFIG3_SLEEP_EN = _pyupm_bma220.BMA220_ENABLE_CONFIG3_SLEEP_EN
    SLEEP_DUR_2MS = _pyupm_bma220.BMA220_SLEEP_DUR_2MS
    SLEEP_DUR_10MS = _pyupm_bma220.BMA220_SLEEP_DUR_10MS
    SLEEP_DUR_25MS = _pyupm_bma220.BMA220_SLEEP_DUR_25MS
    SLEEP_DUR_50MS = _pyupm_bma220.BMA220_SLEEP_DUR_50MS
    SLEEP_DUR_100MS = _pyupm_bma220.BMA220_SLEEP_DUR_100MS
    SLEEP_DUR_500MS = _pyupm_bma220.BMA220_SLEEP_DUR_500MS
    SLEEP_DUR_1S = _pyupm_bma220.BMA220_SLEEP_DUR_1S
    SLEEP_DUR_2S = _pyupm_bma220.BMA220_SLEEP_DUR_2S
    FILTER_CONFIG_FILTER0 = _pyupm_bma220.BMA220_FILTER_CONFIG_FILTER0
    FILTER_CONFIG_FILTER1 = _pyupm_bma220.BMA220_FILTER_CONFIG_FILTER1
    FILTER_CONFIG_FILTER2 = _pyupm_bma220.BMA220_FILTER_CONFIG_FILTER2
    FILTER_CONFIG_FILTER3 = _pyupm_bma220.BMA220_FILTER_CONFIG_FILTER3
    _FILTER_CONFIG_FILTER_MASK = _pyupm_bma220.BMA220__FILTER_CONFIG_FILTER_MASK
    _FILTER_CONFIG_FILTER_SHIFT = _pyupm_bma220.BMA220__FILTER_CONFIG_FILTER_SHIFT
    FILTER_CONFIG_SERIAL_HIGH_BW = _pyupm_bma220.BMA220_FILTER_CONFIG_SERIAL_HIGH_BW
    FILTER_CONFIG_1KHZ = _pyupm_bma220.BMA220_FILTER_CONFIG_1KHZ
    FILTER_CONFIG_500HZ = _pyupm_bma220.BMA220_FILTER_CONFIG_500HZ
    FILTER_CONFIG_250HZ = _pyupm_bma220.BMA220_FILTER_CONFIG_250HZ
    FILTER_CONFIG_125HZ = _pyupm_bma220.BMA220_FILTER_CONFIG_125HZ
    FILTER_CONFIG_64HZ = _pyupm_bma220.BMA220_FILTER_CONFIG_64HZ
    FILTER_CONFIG_32HZ = _pyupm_bma220.BMA220_FILTER_CONFIG_32HZ
    REG_SBIST_FSL_RANGE0 = _pyupm_bma220.BMA220_REG_SBIST_FSL_RANGE0
    REG_SBIST_FSL_RANGE1 = _pyupm_bma220.BMA220_REG_SBIST_FSL_RANGE1
    _REG_SBIST_FSL_RANGE_MASK = _pyupm_bma220.BMA220__REG_SBIST_FSL_RANGE_MASK
    _REG_SBIST_FSL_RANGE_SHIFT = _pyupm_bma220.BMA220__REG_SBIST_FSL_RANGE_SHIFT
    REG_SBIST_FSL_SBIST0 = _pyupm_bma220.BMA220_REG_SBIST_FSL_SBIST0
    REG_SBIST_FSL_SBIST1 = _pyupm_bma220.BMA220_REG_SBIST_FSL_SBIST1
    _REG_SBIST_FSL_SBIST_MASK = _pyupm_bma220.BMA220__REG_SBIST_FSL_SBIST_MASK
    _REG_SBIST_FSL_SBIST_SHIFT = _pyupm_bma220.BMA220__REG_SBIST_FSL_SBIST_SHIFT
    REG_SBIST_FSL_SBIST_SIGN = _pyupm_bma220.BMA220_REG_SBIST_FSL_SBIST_SIGN
    FSL_RANGE_2G = _pyupm_bma220.BMA220_FSL_RANGE_2G
    FSL_RANGE_4G = _pyupm_bma220.BMA220_FSL_RANGE_4G
    FSL_RANGE_8G = _pyupm_bma220.BMA220_FSL_RANGE_8G
    FSL_RANGE_16G = _pyupm_bma220.BMA220_FSL_RANGE_16G
    SBIST_OFF = _pyupm_bma220.BMA220_SBIST_OFF
    SBIST_X = _pyupm_bma220.BMA220_SBIST_X
    SBIST_Y = _pyupm_bma220.BMA220_SBIST_Y
    SBIST_Z = _pyupm_bma220.BMA220_SBIST_Z
    I2C_WATCHDOG_SPI3 = _pyupm_bma220.BMA220_I2C_WATCHDOG_SPI3
    I2C_WATCHDOG_TO_SEL = _pyupm_bma220.BMA220_I2C_WATCHDOG_TO_SEL
    I2C_WATCHDOG_TO_EN = _pyupm_bma220.BMA220_I2C_WATCHDOG_TO_EN
    def __init__(self, bus=0, addr=0x0a): 
        """
        __init__(upm::BMA220 self, int bus=0, uint8_t addr=0x0a) -> BMA220

        Parameters:
            bus: int
            addr: uint8_t

        __init__(upm::BMA220 self, int bus=0) -> BMA220

        Parameters:
            bus: int

        __init__(upm::BMA220 self) -> BMA220

        BMA220(int
        bus=BMA220_I2C_BUS, uint8_t addr=BMA220_DEFAULT_ADDR)

        BMA220 constructor

        Parameters:
        -----------

        bus:  i2c bus to use

        address:  the address for this device 
        """
        this = _pyupm_bma220.new_BMA220(bus, addr)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_bma220.delete_BMA220
    __del__ = lambda self : None;
    def update(self):
        """
        update(BMA220 self)

        Parameters:
            self: upm::BMA220 *


        void update()

        update the accelerometer values 
        """
        return _pyupm_bma220.BMA220_update(self)

    def readReg(self, *args):
        """
        readReg(BMA220 self, uint8_t reg) -> uint8_t

        Parameters:
            reg: uint8_t


        uint8_t readReg(uint8_t
        reg)

        read a register

        Parameters:
        -----------

        dev:  the device to access (XM or G)

        reg:  the register to read

        the value of the register 
        """
        return _pyupm_bma220.BMA220_readReg(self, *args)

    def writeReg(self, *args):
        """
        writeReg(BMA220 self, uint8_t reg, uint8_t val) -> bool

        Parameters:
            reg: uint8_t
            val: uint8_t


        bool writeReg(uint8_t
        reg, uint8_t val)

        write to a register

        Parameters:
        -----------

        dev:  the device to access (XM or G)

        reg:  the register to write to

        val:  the value to write

        true if successful, false otherwise 
        """
        return _pyupm_bma220.BMA220_writeReg(self, *args)

    def getChipID(self):
        """
        getChipID(BMA220 self) -> uint8_t

        Parameters:
            self: upm::BMA220 *


        uint8_t getChipID()

        return the chip ID

        the chip ID (usually 0xdd) 
        """
        return _pyupm_bma220.BMA220_getChipID(self)

    def getChipRevision(self):
        """
        getChipRevision(BMA220 self) -> uint8_t

        Parameters:
            self: upm::BMA220 *


        uint8_t
        getChipRevision()

        return the chip revision

        the chip revision (usually 0x00) 
        """
        return _pyupm_bma220.BMA220_getChipRevision(self)

    def setAccelerometerScale(self, *args):
        """
        setAccelerometerScale(BMA220 self, upm::BMA220::FSL_RANGE_T scale) -> bool

        Parameters:
            scale: enum upm::BMA220::FSL_RANGE_T


        bool
        setAccelerometerScale(FSL_RANGE_T scale)

        set the scaling mode of the accelerometer (2g/4g/8g/16g)

        Parameters:
        -----------

        scale:  one of the FSL_RANGE_T values

        true if successful, false otherwise 
        """
        return _pyupm_bma220.BMA220_setAccelerometerScale(self, *args)

    def getAccelerometer(self, *args):
        """
        getAccelerometer(BMA220 self, float * x, float * y, float * z)

        Parameters:
            x: float *
            y: float *
            z: float *


        void
        getAccelerometer(float *x, float *y, float *z)

        get the accelerometer values in gravities

        Parameters:
        -----------

        x:  the returned x value, if arg is non-NULL

        y:  the returned y value, if arg is non-NULL

        z:  the returned z value, if arg is non-NULL 
        """
        return _pyupm_bma220.BMA220_getAccelerometer(self, *args)

    def setFilterConfig(self, *args):
        """
        setFilterConfig(BMA220 self, upm::BMA220::FILTER_CONFIG_T filter) -> bool

        Parameters:
            filter: enum upm::BMA220::FILTER_CONFIG_T


        bool
        setFilterConfig(FILTER_CONFIG_T filter)

        set the filtering configuration

        Parameters:
        -----------

        filter:  one of the FILTER_CONFIG_T values

        true if successful 
        """
        return _pyupm_bma220.BMA220_setFilterConfig(self, *args)

    def setSerialHighBW(self, *args):
        """
        setSerialHighBW(BMA220 self, bool high) -> bool

        Parameters:
            high: bool


        bool
        setSerialHighBW(bool high)

        enable or disable high bandwidth serial access (1Khz). This
        essentially disables filtering and makes the raw unfiltered data
        available in the axis registers.

        Parameters:
        -----------

        high:  true to enable high bw access, false otherwise

        true if successful 
        """
        return _pyupm_bma220.BMA220_setSerialHighBW(self, *args)

    def enableAxes(self, *args):
        """
        enableAxes(BMA220 self, bool xEn, bool yEn, bool zEn) -> bool

        Parameters:
            xEn: bool
            yEn: bool
            zEn: bool


        bool enableAxes(bool
        xEn, bool yEn, bool zEn)

        enable or disable axis channels

        Parameters:
        -----------

        xEn:  true to enable the axis, false otherwise

        yEn:  true to enable the axis, false otherwise

        zEn:  true to enable the axis, false otherwise

        true if successful 
        """
        return _pyupm_bma220.BMA220_enableAxes(self, *args)

    def suspend(self):
        """
        suspend(BMA220 self) -> uint8_t

        Parameters:
            self: upm::BMA220 *


        uint8_t suspend()

        place the device into, or take the device out of suspend mode

        0x00 if the device was in active mode, 0xff if the device was in
        suspend mode 
        """
        return _pyupm_bma220.BMA220_suspend(self)

    def softReset(self):
        """
        softReset(BMA220 self) -> uint8_t

        Parameters:
            self: upm::BMA220 *


        uint8_t softReset()

        place the device into, or take the device out of soft reset mode

        0x00 if the device was in active mode, 0xff if the device was in soft
        reset mode 
        """
        return _pyupm_bma220.BMA220_softReset(self)

    def sleep(self, *args):
        """
        sleep(BMA220 self, bool enable) -> bool

        Parameters:
            enable: bool


        bool sleep(bool enable)

        place the device into, or take the device out of low power mode. See
        the datasheet for information on how low power mode is implemented on
        this device.

        Parameters:
        -----------

        enable:  true to set low power mode, false otherwise

        true if successful 
        """
        return _pyupm_bma220.BMA220_sleep(self, *args)

    def setSleepDuration(self, *args):
        """
        setSleepDuration(BMA220 self, upm::BMA220::SLEEP_DUR_T dur) -> bool

        Parameters:
            dur: enum upm::BMA220::SLEEP_DUR_T


        bool
        setSleepDuration(SLEEP_DUR_T dur)

        when in low power (sleep) mode, specify how often the device wakes up
        to acquire samples.

        Parameters:
        -----------

        dur:  one of the SLEEP_DUR_T values

        true if successful 
        """
        return _pyupm_bma220.BMA220_setSleepDuration(self, *args)

    def setLowGThreshold(self, *args):
        """
        setLowGThreshold(BMA220 self, uint8_t thresh) -> bool

        Parameters:
            thresh: uint8_t


        bool
        setLowGThreshold(uint8_t thresh)

        specify the threshold for low G detection

        Parameters:
        -----------

        thresh:  see the datasheet

        true if successful 
        """
        return _pyupm_bma220.BMA220_setLowGThreshold(self, *args)

    def setHighGThreshold(self, *args):
        """
        setHighGThreshold(BMA220 self, uint8_t thresh) -> bool

        Parameters:
            thresh: uint8_t


        bool
        setHighGThreshold(uint8_t thresh)

        specify the threshold for high G detection

        Parameters:
        -----------

        thresh:  see the datasheet

        true if successful 
        """
        return _pyupm_bma220.BMA220_setHighGThreshold(self, *args)

    def setLowGHysteresis(self, *args):
        """
        setLowGHysteresis(BMA220 self, uint8_t hyst) -> bool

        Parameters:
            hyst: uint8_t


        bool
        setLowGHysteresis(uint8_t hyst)

        specify the hysteresis for low G detection

        Parameters:
        -----------

        hyst:  2 bit hysteresis value

        true if successful 
        """
        return _pyupm_bma220.BMA220_setLowGHysteresis(self, *args)

    def setLowGDuration(self, *args):
        """
        setLowGDuration(BMA220 self, uint8_t dur) -> bool

        Parameters:
            dur: uint8_t


        bool
        setLowGDuration(uint8_t dur)

        specify the sample duration for low G detection

        Parameters:
        -----------

        dur:  the number of samples (depends on bandwidth)

        true if successful 
        """
        return _pyupm_bma220.BMA220_setLowGDuration(self, *args)

    def setHighGHysteresis(self, *args):
        """
        setHighGHysteresis(BMA220 self, uint8_t hyst) -> bool

        Parameters:
            hyst: uint8_t


        bool
        setHighGHysteresis(uint8_t hyst)

        specify the hysteresis for high G detection

        Parameters:
        -----------

        hyst:  2 bit hysteresis value

        true if successful 
        """
        return _pyupm_bma220.BMA220_setHighGHysteresis(self, *args)

    def setHighGDuration(self, *args):
        """
        setHighGDuration(BMA220 self, uint8_t dur) -> bool

        Parameters:
            dur: uint8_t


        bool
        setHighGDuration(uint8_t dur)

        specify the sample duration for high G detection

        Parameters:
        -----------

        dur:  the number of samples (depends on bandwidth)

        true if successful 
        """
        return _pyupm_bma220.BMA220_setHighGDuration(self, *args)

    def setTapDuration(self, *args):
        """
        setTapDuration(BMA220 self, uint8_t dur) -> bool

        Parameters:
            dur: uint8_t


        bool
        setTapDuration(uint8_t dur)

        specify the sample duration for tap detection

        Parameters:
        -----------

        dur:  the number of samples (depends on bandwidth)

        true if successful 
        """
        return _pyupm_bma220.BMA220_setTapDuration(self, *args)

    def setTapThreshold(self, *args):
        """
        setTapThreshold(BMA220 self, uint8_t thresh) -> bool

        Parameters:
            thresh: uint8_t


        bool
        setTapThreshold(uint8_t thresh)

        specify the threshold for tap detection

        Parameters:
        -----------

        thresh:  see the datasheet

        true if successful 
        """
        return _pyupm_bma220.BMA220_setTapThreshold(self, *args)

    def enableTapFilter(self, *args):
        """
        enableTapFilter(BMA220 self, bool filt) -> bool

        Parameters:
            filt: bool


        bool
        enableTapFilter(bool filt)

        unable to disable tap filtering

        Parameters:
        -----------

        filt:  true to enable, false otherwise

        true if successful 
        """
        return _pyupm_bma220.BMA220_enableTapFilter(self, *args)

    def setSlopeDuration(self, *args):
        """
        setSlopeDuration(BMA220 self, uint8_t dur) -> bool

        Parameters:
            dur: uint8_t


        bool
        setSlopeDuration(uint8_t dur)

        specify the sample duration for slope detection

        Parameters:
        -----------

        dur:  the number of samples (depends on bandwidth)

        true if successful 
        """
        return _pyupm_bma220.BMA220_setSlopeDuration(self, *args)

    def setSlopeThreshold(self, *args):
        """
        setSlopeThreshold(BMA220 self, uint8_t thresh) -> bool

        Parameters:
            thresh: uint8_t


        bool
        setSlopeThreshold(uint8_t thresh)

        specify the threshold for slope detection

        Parameters:
        -----------

        thresh:  see the datasheet

        true if successful 
        """
        return _pyupm_bma220.BMA220_setSlopeThreshold(self, *args)

    def enableSlopeFilter(self, *args):
        """
        enableSlopeFilter(BMA220 self, bool filt) -> bool

        Parameters:
            filt: bool


        bool
        enableSlopeFilter(bool filt)

        enable or disable slope filtering

        Parameters:
        -----------

        filt:  true to enable filtering, false otherwise

        true if successful 
        """
        return _pyupm_bma220.BMA220_enableSlopeFilter(self, *args)

    def getInterruptStatus1(self):
        """
        getInterruptStatus1(BMA220 self) -> uint8_t

        Parameters:
            self: upm::BMA220 *


        uint8_t
        getInterruptStatus1()

        return a bitmask of the interrupt status 1 register

        bitmask of INT_STATUS1_BITS_T bits (minus the orient value) 
        """
        return _pyupm_bma220.BMA220_getInterruptStatus1(self)

    def getOrient(self):
        """
        getOrient(BMA220 self) -> upm::BMA220::CONFIG_ORIENT_T

        Parameters:
            self: upm::BMA220 *


        BMA220::CONFIG_ORIENT_T getOrient()

        return the orient value from the interrupt status 1 register

        one of the CONFIG_ORIENT_T values 
        """
        return _pyupm_bma220.BMA220_getOrient(self)

    def getInterruptStatus2(self):
        """
        getInterruptStatus2(BMA220 self) -> uint8_t

        Parameters:
            self: upm::BMA220 *


        uint8_t
        getInterruptStatus2()

        return a bitmask of the interrupt status 2 register

        bitmask of INT_STATUS2_BITS_T bits 
        """
        return _pyupm_bma220.BMA220_getInterruptStatus2(self)

    def setInterruptEnables1(self, *args):
        """
        setInterruptEnables1(BMA220 self, uint8_t bits) -> bool

        Parameters:
            bits: uint8_t


        bool
        setInterruptEnables1(uint8_t bits)

        enable interrupts for events in interrupt config register 1

        Parameters:
        -----------

        bits:  bitmask of ENABLE_CONFIG_BITS_T values

        true if successful 
        """
        return _pyupm_bma220.BMA220_setInterruptEnables1(self, *args)

    def getInterruptEnables1(self):
        """
        getInterruptEnables1(BMA220 self) -> uint8_t

        Parameters:
            self: upm::BMA220 *


        uint8_t
        getInterruptEnables1()

        return the enabled interrupts for events in interrupt config register
        1

        bitmask of ENABLE_CONFIG_BITS_T values 
        """
        return _pyupm_bma220.BMA220_getInterruptEnables1(self)

    def setInterruptEnables2(self, *args):
        """
        setInterruptEnables2(BMA220 self, uint8_t bits) -> bool

        Parameters:
            bits: uint8_t


        bool
        setInterruptEnables2(uint8_t bits)

        enable interrupts for events in interrupt config register 2

        Parameters:
        -----------

        bits:  bitmask of ENABLE_CONFIG2_BITS_T values

        true if successful 
        """
        return _pyupm_bma220.BMA220_setInterruptEnables2(self, *args)

    def getInterruptEnables2(self):
        """
        getInterruptEnables2(BMA220 self) -> uint8_t

        Parameters:
            self: upm::BMA220 *


        uint8_t
        getInterruptEnables2()

        return the enabled interrupts for events in interrupt config register
        2

        bitmask of ENABLE_CONFIG2_BITS_T values 
        """
        return _pyupm_bma220.BMA220_getInterruptEnables2(self)

    def setInterruptLatch(self, *args):
        """
        setInterruptLatch(BMA220 self, upm::BMA220::CONFIG2_LAT_T lat) -> bool

        Parameters:
            lat: enum upm::BMA220::CONFIG2_LAT_T


        bool
        setInterruptLatch(CONFIG2_LAT_T lat)

        configure interrupt latching behavior

        Parameters:
        -----------

        lat:  one of the CONFIG2_LAT_T values

        true if successful 
        """
        return _pyupm_bma220.BMA220_setInterruptLatch(self, *args)

    def resetInterrupts(self):
        """
        resetInterrupts(BMA220 self) -> bool

        Parameters:
            self: upm::BMA220 *


        bool
        resetInterrupts()

        reset the interrupt controller. This should be called after any
        changes are made to interrupt configuration, or to reset interrupts if
        latched interrupts have been enabled and an interrupt has occurred..

        true if successful 
        """
        return _pyupm_bma220.BMA220_resetInterrupts(self)

    def installISR(self, *args):
        """
        installISR(BMA220 self, int gpio, mraa::Edge level, void (*)(void *) isr, void * arg)

        Parameters:
            gpio: int
            level: mraa::Edge
            isr: void (*)(void *)
            arg: void *


        void installISR(int
        gpio, mraa::Edge level, void(*isr)(void *), void *arg)

        install an interrupt handler.

        Parameters:
        -----------

        gpio:  gpio pin to use as interrupt pin

        level:  the interrupt trigger level (one of mraa::Edge values). Make
        sure that you have configured the interrupt pin properly for whatever
        level you choose.

        isr:  the interrupt handler, accepting a void * argument

        arg:  the argument to pass the the interrupt handler 
        """
        return _pyupm_bma220.BMA220_installISR(self, *args)

    def uninstallISR(self):
        """
        uninstallISR(BMA220 self)

        Parameters:
            self: upm::BMA220 *


        void uninstallISR()

        uninstall a previously installed interrupt handler 
        """
        return _pyupm_bma220.BMA220_uninstallISR(self)

BMA220_swigregister = _pyupm_bma220.BMA220_swigregister
BMA220_swigregister(BMA220)

# This file is compatible with both classic and new-style classes.


