# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_pn532', [dirname(__file__)])
        except ImportError:
            import _pyupm_pn532
            return _pyupm_pn532
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_pn532', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_pn532 = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_pn532
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class uint8Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint8Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint8Array, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pyupm_pn532.new_uint8Array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_pn532.delete_uint8Array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _pyupm_pn532.uint8Array___getitem__(self, *args)
    def __setitem__(self, *args): return _pyupm_pn532.uint8Array___setitem__(self, *args)
    def cast(self): return _pyupm_pn532.uint8Array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _pyupm_pn532.uint8Array_frompointer
    if _newclass:frompointer = staticmethod(_pyupm_pn532.uint8Array_frompointer)
uint8Array_swigregister = _pyupm_pn532.uint8Array_swigregister
uint8Array_swigregister(uint8Array)

def uint8Array_frompointer(*args):
  return _pyupm_pn532.uint8Array_frompointer(*args)
uint8Array_frompointer = _pyupm_pn532.uint8Array_frompointer

PN532_I2C_BUS = _pyupm_pn532.PN532_I2C_BUS
PN532_DEFAULT_I2C_ADDR = _pyupm_pn532.PN532_DEFAULT_I2C_ADDR
PN532_PREAMBLE = _pyupm_pn532.PN532_PREAMBLE
PN532_STARTCODE1 = _pyupm_pn532.PN532_STARTCODE1
PN532_STARTCODE2 = _pyupm_pn532.PN532_STARTCODE2
PN532_POSTAMBLE = _pyupm_pn532.PN532_POSTAMBLE
PN532_HOSTTOPN532 = _pyupm_pn532.PN532_HOSTTOPN532
PN532_PN532TOHOST = _pyupm_pn532.PN532_PN532TOHOST
class PN532(_object):
    """
    API for the PN532 based NFC/RFID reader/writer.

    ID: pn532

    Name: PN532 NFC/RFID reader/writer

    Category: rfid

    Manufacturer: adafruit

    Link:http://www.adafruit.com/products/364

    Connection: i2c   Identify a card and print out basic infoAdd a URI to
    an already NDEF formatted ultralight or NTAG2XX tag

    C++ includes: pn532.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PN532, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PN532, name)
    __repr__ = _swig_repr
    CMD_DIAGNOSE = _pyupm_pn532.PN532_CMD_DIAGNOSE
    CMD_GETFIRMWAREVERSION = _pyupm_pn532.PN532_CMD_GETFIRMWAREVERSION
    CMD_GETGENERALSTATUS = _pyupm_pn532.PN532_CMD_GETGENERALSTATUS
    CMD_READREGISTER = _pyupm_pn532.PN532_CMD_READREGISTER
    CMD_WRITEREGISTER = _pyupm_pn532.PN532_CMD_WRITEREGISTER
    CMD_READGPIO = _pyupm_pn532.PN532_CMD_READGPIO
    CMD_WRITEGPIO = _pyupm_pn532.PN532_CMD_WRITEGPIO
    CMD_SETSERIALBAUDRATE = _pyupm_pn532.PN532_CMD_SETSERIALBAUDRATE
    CMD_SETPARAMETERS = _pyupm_pn532.PN532_CMD_SETPARAMETERS
    CMD_SAMCONFIGURATION = _pyupm_pn532.PN532_CMD_SAMCONFIGURATION
    CMD_POWERDOWN = _pyupm_pn532.PN532_CMD_POWERDOWN
    CMD_RFCONFIGURATION = _pyupm_pn532.PN532_CMD_RFCONFIGURATION
    CMD_RFREGULATIONTEST = _pyupm_pn532.PN532_CMD_RFREGULATIONTEST
    CMD_INJUMPFORDEP = _pyupm_pn532.PN532_CMD_INJUMPFORDEP
    CMD_INJUMPFORPSL = _pyupm_pn532.PN532_CMD_INJUMPFORPSL
    CMD_INLISTPASSIVETARGET = _pyupm_pn532.PN532_CMD_INLISTPASSIVETARGET
    CMD_INATR = _pyupm_pn532.PN532_CMD_INATR
    CMD_INPSL = _pyupm_pn532.PN532_CMD_INPSL
    CMD_INDATAEXCHANGE = _pyupm_pn532.PN532_CMD_INDATAEXCHANGE
    CMD_INCOMMUNICATETHRU = _pyupm_pn532.PN532_CMD_INCOMMUNICATETHRU
    CMD_INDESELECT = _pyupm_pn532.PN532_CMD_INDESELECT
    CMD_INRELEASE = _pyupm_pn532.PN532_CMD_INRELEASE
    CMD_INSELECT = _pyupm_pn532.PN532_CMD_INSELECT
    CMD_INAUTOPOLL = _pyupm_pn532.PN532_CMD_INAUTOPOLL
    CMD_TGINITASTARGET = _pyupm_pn532.PN532_CMD_TGINITASTARGET
    CMD_TGSETGENERALBYTES = _pyupm_pn532.PN532_CMD_TGSETGENERALBYTES
    CMD_TGGETDATA = _pyupm_pn532.PN532_CMD_TGGETDATA
    CMD_TGSETDATA = _pyupm_pn532.PN532_CMD_TGSETDATA
    CMD_TGSETMETADATA = _pyupm_pn532.PN532_CMD_TGSETMETADATA
    CMD_TGGETINITIATORCOMMAND = _pyupm_pn532.PN532_CMD_TGGETINITIATORCOMMAND
    CMD_TGRESPONSETOINITIATOR = _pyupm_pn532.PN532_CMD_TGRESPONSETOINITIATOR
    CMD_TGGETTARGETSTATUS = _pyupm_pn532.PN532_CMD_TGGETTARGETSTATUS
    RSP_INDATAEXCHANGE = _pyupm_pn532.PN532_RSP_INDATAEXCHANGE
    RSP_INLISTPASSIVETARGET = _pyupm_pn532.PN532_RSP_INLISTPASSIVETARGET
    MIFARE_CMD_AUTH_A = _pyupm_pn532.PN532_MIFARE_CMD_AUTH_A
    MIFARE_CMD_AUTH_B = _pyupm_pn532.PN532_MIFARE_CMD_AUTH_B
    MIFARE_CMD_READ = _pyupm_pn532.PN532_MIFARE_CMD_READ
    MIFARE_CMD_WRITE = _pyupm_pn532.PN532_MIFARE_CMD_WRITE
    MIFARE_CMD_TRANSFER = _pyupm_pn532.PN532_MIFARE_CMD_TRANSFER
    MIFARE_CMD_DECREMENT = _pyupm_pn532.PN532_MIFARE_CMD_DECREMENT
    MIFARE_CMD_INCREMENT = _pyupm_pn532.PN532_MIFARE_CMD_INCREMENT
    MIFARE_CMD_STORE = _pyupm_pn532.PN532_MIFARE_CMD_STORE
    MIFARE_ULTRALIGHT_CMD_WRITE = _pyupm_pn532.PN532_MIFARE_ULTRALIGHT_CMD_WRITE
    NDEF_URIPREFIX_NONE = _pyupm_pn532.PN532_NDEF_URIPREFIX_NONE
    NDEF_URIPREFIX_HTTP_WWWDOT = _pyupm_pn532.PN532_NDEF_URIPREFIX_HTTP_WWWDOT
    NDEF_URIPREFIX_HTTPS_WWWDOT = _pyupm_pn532.PN532_NDEF_URIPREFIX_HTTPS_WWWDOT
    NDEF_URIPREFIX_HTTP = _pyupm_pn532.PN532_NDEF_URIPREFIX_HTTP
    NDEF_URIPREFIX_HTTPS = _pyupm_pn532.PN532_NDEF_URIPREFIX_HTTPS
    NDEF_URIPREFIX_TEL = _pyupm_pn532.PN532_NDEF_URIPREFIX_TEL
    NDEF_URIPREFIX_MAILTO = _pyupm_pn532.PN532_NDEF_URIPREFIX_MAILTO
    NDEF_URIPREFIX_FTP_ANONAT = _pyupm_pn532.PN532_NDEF_URIPREFIX_FTP_ANONAT
    NDEF_URIPREFIX_FTP_FTPDOT = _pyupm_pn532.PN532_NDEF_URIPREFIX_FTP_FTPDOT
    NDEF_URIPREFIX_FTPS = _pyupm_pn532.PN532_NDEF_URIPREFIX_FTPS
    NDEF_URIPREFIX_SFTP = _pyupm_pn532.PN532_NDEF_URIPREFIX_SFTP
    NDEF_URIPREFIX_SMB = _pyupm_pn532.PN532_NDEF_URIPREFIX_SMB
    NDEF_URIPREFIX_NFS = _pyupm_pn532.PN532_NDEF_URIPREFIX_NFS
    NDEF_URIPREFIX_FTP = _pyupm_pn532.PN532_NDEF_URIPREFIX_FTP
    NDEF_URIPREFIX_DAV = _pyupm_pn532.PN532_NDEF_URIPREFIX_DAV
    NDEF_URIPREFIX_NEWS = _pyupm_pn532.PN532_NDEF_URIPREFIX_NEWS
    NDEF_URIPREFIX_TELNET = _pyupm_pn532.PN532_NDEF_URIPREFIX_TELNET
    NDEF_URIPREFIX_IMAP = _pyupm_pn532.PN532_NDEF_URIPREFIX_IMAP
    NDEF_URIPREFIX_RTSP = _pyupm_pn532.PN532_NDEF_URIPREFIX_RTSP
    NDEF_URIPREFIX_URN = _pyupm_pn532.PN532_NDEF_URIPREFIX_URN
    NDEF_URIPREFIX_POP = _pyupm_pn532.PN532_NDEF_URIPREFIX_POP
    NDEF_URIPREFIX_SIP = _pyupm_pn532.PN532_NDEF_URIPREFIX_SIP
    NDEF_URIPREFIX_SIPS = _pyupm_pn532.PN532_NDEF_URIPREFIX_SIPS
    NDEF_URIPREFIX_TFTP = _pyupm_pn532.PN532_NDEF_URIPREFIX_TFTP
    NDEF_URIPREFIX_BTSPP = _pyupm_pn532.PN532_NDEF_URIPREFIX_BTSPP
    NDEF_URIPREFIX_BTL2CAP = _pyupm_pn532.PN532_NDEF_URIPREFIX_BTL2CAP
    NDEF_URIPREFIX_BTGOEP = _pyupm_pn532.PN532_NDEF_URIPREFIX_BTGOEP
    NDEF_URIPREFIX_TCPOBEX = _pyupm_pn532.PN532_NDEF_URIPREFIX_TCPOBEX
    NDEF_URIPREFIX_IRDAOBEX = _pyupm_pn532.PN532_NDEF_URIPREFIX_IRDAOBEX
    NDEF_URIPREFIX_FILE = _pyupm_pn532.PN532_NDEF_URIPREFIX_FILE
    NDEF_URIPREFIX_URN_EPC_ID = _pyupm_pn532.PN532_NDEF_URIPREFIX_URN_EPC_ID
    NDEF_URIPREFIX_URN_EPC_TAG = _pyupm_pn532.PN532_NDEF_URIPREFIX_URN_EPC_TAG
    NDEF_URIPREFIX_URN_EPC_PAT = _pyupm_pn532.PN532_NDEF_URIPREFIX_URN_EPC_PAT
    NDEF_URIPREFIX_URN_EPC_RAW = _pyupm_pn532.PN532_NDEF_URIPREFIX_URN_EPC_RAW
    NDEF_URIPREFIX_URN_EPC = _pyupm_pn532.PN532_NDEF_URIPREFIX_URN_EPC
    NDEF_URIPREFIX_URN_NFC = _pyupm_pn532.PN532_NDEF_URIPREFIX_URN_NFC
    BAUD_MIFARE_ISO14443A = _pyupm_pn532.PN532_BAUD_MIFARE_ISO14443A
    TAG_TYPE_UNKNOWN = _pyupm_pn532.PN532_TAG_TYPE_UNKNOWN
    TAG_TYPE_MIFARE_CLASSIC = _pyupm_pn532.PN532_TAG_TYPE_MIFARE_CLASSIC
    TAG_TYPE_NFC2 = _pyupm_pn532.PN532_TAG_TYPE_NFC2
    def __init__(self, *args): 
        """
        __init__(upm::PN532 self, int irq, int reset, int bus=0, uint8_t address=(0x48 >> 1)) -> PN532

        Parameters:
            irq: int
            reset: int
            bus: int
            address: uint8_t

        __init__(upm::PN532 self, int irq, int reset, int bus=0) -> PN532

        Parameters:
            irq: int
            reset: int
            bus: int

        __init__(upm::PN532 self, int irq, int reset) -> PN532

        Parameters:
            irq: int
            reset: int


        PN532(int irq, int reset,
        int bus=PN532_I2C_BUS, uint8_t address=PN532_DEFAULT_I2C_ADDR)

        pn532 constructor

        Parameters:
        -----------

        irq:  pin to use for IRQ

        reset:  reset pin

        bus:  i2c bus to use

        address:  the address for this device 
        """
        this = _pyupm_pn532.new_PN532(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_pn532.delete_PN532
    __del__ = lambda self : None;
    def init(self):
        """
        init(PN532 self) -> bool

        Parameters:
            self: upm::PN532 *


        bool init()

        set up initial values and start operation

        true if successful 
        """
        return _pyupm_pn532.PN532_init(self)

    def getFirmwareVersion(self):
        """
        getFirmwareVersion(PN532 self) -> uint32_t

        Parameters:
            self: upm::PN532 *


        uint32_t
        getFirmwareVersion()

        Checks the firmware version of the PN5xx chip.

        Checks the firmware version of the PN5xx chip

        the chip's firmware version and ID

        The chip's firmware version and ID 
        """
        return _pyupm_pn532.PN532_getFirmwareVersion(self)

    def sendCommandCheckAck(self, *args):
        """
        sendCommandCheckAck(PN532 self, uint8_t * cmd, uint8_t cmdlen, uint16_t timeout=1000) -> bool

        Parameters:
            cmd: uint8_t *
            cmdlen: uint8_t
            timeout: uint16_t

        sendCommandCheckAck(PN532 self, uint8_t * cmd, uint8_t cmdlen) -> bool

        Parameters:
            cmd: uint8_t *
            cmdlen: uint8_t


        bool
        sendCommandCheckAck(uint8_t *cmd, uint8_t cmdlen, uint16_t
        timeout=1000)

        Sends a command and waits a specified period for the ACK.

        sends a command and waits a specified period for the ACK

        Parameters:
        -----------

        cmd:  Pointer to the command buffer

        cmdlen:  the size of the command in bytes

        timeout:  timeout before giving up (in ms)

        true if everything is OK, false if timeout occured before an ACK was
        recieved

        Parameters:
        -----------

        cmd:  Pointer to the command buffer

        cmdlen:  The size of the command in bytes

        timeout:  timeout before giving up

        1 if everything is OK, 0 if timeout occured before an ACK was recieved

        """
        return _pyupm_pn532.PN532_sendCommandCheckAck(self, *args)

    def SAMConfig(self):
        """
        SAMConfig(PN532 self) -> bool

        Parameters:
            self: upm::PN532 *


        bool SAMConfig(void)

        Configures the SAM (Secure Access Module)

        configures the SAM (Secure Access Module)

        true if successfully configured 
        """
        return _pyupm_pn532.PN532_SAMConfig(self)

    def setPassiveActivationRetries(self, *args):
        """
        setPassiveActivationRetries(PN532 self, uint8_t maxRetries) -> bool

        Parameters:
            maxRetries: uint8_t


        bool
        setPassiveActivationRetries(uint8_t maxRetries)

        sets the MxRtyPassiveActivation byte of the RFConfiguration register.
        By default the pn532 will retry indefinitely.

        Parameters:
        -----------

        maxRetries:  0xFF to wait forever, 0x00..0xFE to timeout after
        maxRetries. 0x00 means try once, with no retries on failure.

        true if everything executed properly, false for an error  Sets the
        MxRtyPassiveActivation byte of the RFConfiguration register

        Parameters:
        -----------

        maxRetries:  0xFF to wait forever, 0x00..0xFE to timeout after
        mxRetries

        1 if everything executed properly, 0 for an error 
        """
        return _pyupm_pn532.PN532_setPassiveActivationRetries(self, *args)

    def readPassiveTargetID(self, *args):
        """
        readPassiveTargetID(PN532 self, upm::PN532::BAUD_T cardbaudrate, uint8_t * uid, uint8_t * uidLength, uint16_t timeout) -> bool

        Parameters:
            cardbaudrate: enum upm::PN532::BAUD_T
            uid: uint8_t *
            uidLength: uint8_t *
            timeout: uint16_t


        bool
        readPassiveTargetID(BAUD_T cardbaudrate, uint8_t *uid, uint8_t
        *uidLength, uint16_t timeout)

        waits for an ISO14443A target to enter the field

        Parameters:
        -----------

        cardbaudbate:  baud rate of the card, one of the BAUD_T values

        uid:  Pointer to the array that will be populated with the cards UID,
        up to 7 bytes

        uidLength:  Pointer to the variable that will hold the length of the
        card's UID.

        timeout:  the number of milliseconds to wait

        true if everything executed properly, false for an error  Waits for an
        ISO14443A target to enter the field

        Parameters:
        -----------

        cardBaudRate:  Baud rate of the card

        uid:  Pointer to the array that will be populated with the card's UID
        (up to 7 bytes)

        uidLength:  Pointer to the variable that will hold the length of the
        card's UID.

        1 if everything executed properly, 0 for an error 
        """
        return _pyupm_pn532.PN532_readPassiveTargetID(self, *args)

    def inDataExchange(self, *args):
        """
        inDataExchange(PN532 self, uint8_t * send, uint8_t sendLength, uint8_t * response, uint8_t * responseLength) -> bool

        Parameters:
            send: uint8_t *
            sendLength: uint8_t
            response: uint8_t *
            responseLength: uint8_t *


        bool
        inDataExchange(uint8_t *send, uint8_t sendLength, uint8_t *response,
        uint8_t *responseLength)

        Exchanges an APDU with the currently inlisted peer.

        exchanges an APDU (Application Protocol Data Unit) with the currently
        inlisted peer

        Parameters:
        -----------

        send:  Pointer to data to send

        sendLength:  Length of the data to send

        response:  Pointer to response data

        responseLength:  Pointer to the response data length

        true if everything executed properly, false for an error

        Parameters:
        -----------

        send:  Pointer to data to send

        sendLength:  Length of the data to send

        response:  Pointer to response data

        responseLength:  Pointer to the response data length 
        """
        return _pyupm_pn532.PN532_inDataExchange(self, *args)

    def inListPassiveTarget(self):
        """
        inListPassiveTarget(PN532 self) -> bool

        Parameters:
            self: upm::PN532 *


        bool
        inListPassiveTarget()

        'InLists' a passive target. PN532 acting as reader/initiator, peer
        acting as card/responder.

        'InLists' a passive target. PN532 acting as reader/initiator, peer
        acting as card/responder.

        true if everything executed properly, false for an error 
        """
        return _pyupm_pn532.PN532_inListPassiveTarget(self)

    def mifareclassic_IsFirstBlock(self, *args):
        """
        mifareclassic_IsFirstBlock(PN532 self, uint32_t uiBlock) -> bool

        Parameters:
            uiBlock: uint32_t


        bool
        mifareclassic_IsFirstBlock(uint32_t uiBlock)

        Indicates whether the specified block number is the first block in the
        sector (block 0 relative to the current sector)

        true if it's the first block, false otherwise  Indicates whether the
        specified block number is the first block in the sector (block 0
        relative to the current sector) 
        """
        return _pyupm_pn532.PN532_mifareclassic_IsFirstBlock(self, *args)

    def mifareclassic_IsTrailerBlock(self, *args):
        """
        mifareclassic_IsTrailerBlock(PN532 self, uint32_t uiBlock) -> bool

        Parameters:
            uiBlock: uint32_t


        bool
        mifareclassic_IsTrailerBlock(uint32_t uiBlock)

        indicates whether the specified block number is the sector trailer

        true if it's the trailer block, false otherwise  Indicates whether the
        specified block number is the sector trailer 
        """
        return _pyupm_pn532.PN532_mifareclassic_IsTrailerBlock(self, *args)

    def mifareclassic_AuthenticateBlock(self, *args):
        """
        mifareclassic_AuthenticateBlock(PN532 self, uint8_t * uid, uint8_t uidLen, uint32_t blockNumber, uint8_t keyNumber, uint8_t * keyData) -> bool

        Parameters:
            uid: uint8_t *
            uidLen: uint8_t
            blockNumber: uint32_t
            keyNumber: uint8_t
            keyData: uint8_t *


        bool mifareclassic_AuthenticateBlock(uint8_t *uid, uint8_t uidLen,
        uint32_t blockNumber, uint8_t keyNumber, uint8_t *keyData)

        tries to authenticate a block of memory on a MIFARE card using the
        INDATAEXCHANGE command. See section 7.3.8 of the PN532 User Manual for
        more information on sending MIFARE and other commands.

        Parameters:
        -----------

        uid:  Pointer to a byte array containing the card UID

        uidLen:  The length (in bytes) of the card's UID (Should be 4 for
        MIFARE Classic)

        blockNumber:  The block number to authenticate. (0..63 for 1KB cards,
        and 0..255 for 4KB cards).

        keyNumber:  Which key type to use during authentication (0 =
        MIFARE_CMD_AUTH_A, 1 = MIFARE_CMD_AUTH_B)

        keyData:  Pointer to a byte array containing the 6 byte key value

        true if everything executed properly, false for an error  Tries to
        authenticate a block of memory on a MIFARE card using the
        INDATAEXCHANGE command. See section 7.3.8 of the PN532 User Manual for
        more information on sending MIFARE and other commands.

        Parameters:
        -----------

        uid:  Pointer to a byte array containing the card UID

        uidLen:  The length (in bytes) of the card's UID (Should be 4 for
        MIFARE Classic)

        blockNumber:  The block number to authenticate. (0..63 for 1KB cards,
        and 0..255 for 4KB cards).

        keyNumber:  Which key type to use during authentication (0 =
        MIFARE_CMD_AUTH_A, 1 = MIFARE_CMD_AUTH_B)

        keyData:  Pointer to a byte array containing the 6 byte key value

        1 if everything executed properly, 0 for an error 
        """
        return _pyupm_pn532.PN532_mifareclassic_AuthenticateBlock(self, *args)

    def mifareclassic_ReadDataBlock(self, *args):
        """
        mifareclassic_ReadDataBlock(PN532 self, uint8_t blockNumber, uint8_t * data) -> bool

        Parameters:
            blockNumber: uint8_t
            data: uint8_t *


        bool
        mifareclassic_ReadDataBlock(uint8_t blockNumber, uint8_t *data)

        tries to read an entire 16-byte data block at the specified block
        address.

        Parameters:
        -----------

        blockNumber:  The block number to read (0..63 for 1KB cards, and
        0..255 for 4KB cards).

        data:  Pointer to the byte array that will hold the retrieved data (if
        any)

        true if everything executed properly, false for an error  Tries to
        read an entire 16-byte data block at the specified block address.

        Parameters:
        -----------

        blockNumber:  The block number to authenticate. (0..63 for 1KB cards,
        and 0..255 for 4KB cards).

        data:  Pointer to the byte array that will hold the retrieved data (if
        any)

        1 if everything executed properly, 0 for an error 
        """
        return _pyupm_pn532.PN532_mifareclassic_ReadDataBlock(self, *args)

    def mifareclassic_WriteDataBlock(self, *args):
        """
        mifareclassic_WriteDataBlock(PN532 self, uint8_t blockNumber, uint8_t * data) -> bool

        Parameters:
            blockNumber: uint8_t
            data: uint8_t *


        bool
        mifareclassic_WriteDataBlock(uint8_t blockNumber, uint8_t *data)

        tries to write an entire 16-byte data block at the specified block
        address.

        Parameters:
        -----------

        blockNumber:  The block number to write. (0..63 for 1KB cards, and
        0..255 for 4KB cards).

        data:  The byte array that contains the data to write.

        true if everything executed properly, false for an error  Tries to
        write an entire 16-byte data block at the specified block address.

        Parameters:
        -----------

        blockNumber:  The block number to authenticate. (0..63 for 1KB cards,
        and 0..255 for 4KB cards).

        data:  The byte array that contains the data to write.

        1 if everything executed properly, 0 for an error 
        """
        return _pyupm_pn532.PN532_mifareclassic_WriteDataBlock(self, *args)

    def mifareclassic_FormatNDEF(self):
        """
        mifareclassic_FormatNDEF(PN532 self) -> bool

        Parameters:
            self: upm::PN532 *


        bool
        mifareclassic_FormatNDEF(void)

        formats a Mifare Classic card to store NDEF Records

        true if everything executed properly, false for an error  Formats a
        Mifare Classic card to store NDEF Records

        1 if everything executed properly, 0 for an error 
        """
        return _pyupm_pn532.PN532_mifareclassic_FormatNDEF(self)

    def mifareclassic_WriteNDEFURI(self, *args):
        """
        mifareclassic_WriteNDEFURI(PN532 self, uint8_t sectorNumber, upm::PN532::NDEF_URI_T uriIdentifier, char const * url) -> bool

        Parameters:
            sectorNumber: uint8_t
            uriIdentifier: enum upm::PN532::NDEF_URI_T
            url: char const *


        bool
        mifareclassic_WriteNDEFURI(uint8_t sectorNumber, NDEF_URI_T
        uriIdentifier, const char *url)

        writes an NDEF URI Record to the specified sector (1..15)

        Note that this function assumes that the Mifare Classic card is
        already formatted to work as an "NFC Forum Tag" and uses a MAD1 file
        system. You can use the NXP TagWriter app on Android to properly
        format cards for this.

        Parameters:
        -----------

        sectorNumber:  The sector that the URI record should be written to
        (can be 1..15 for a 1K card)

        uriIdentifier:  The uri identifier code (one of the NDEF_URI_T values

        url:  the uri text to write (max 38 characters).

        true if everything executed properly, false for an error  Writes an
        NDEF URI Record to the specified sector (1..15)

        Note that this function assumes that the Mifare Classic card is
        already formatted to work as an "NFC Forum Tag" and uses a MAD1 file
        system. You can use the NXP TagWriter app on Android to properly
        format cards for this.

        Parameters:
        -----------

        sectorNumber:  The sector that the URI record should be written to
        (can be 1..15 for a 1K card)

        uriIdentifier:  The uri identifier code (0 = none, 0x01 =
        "http://www.", etc.)

        url:  The uri text to write (max 38 characters).

        1 if everything executed properly, 0 for an error 
        """
        return _pyupm_pn532.PN532_mifareclassic_WriteNDEFURI(self, *args)

    def ntag2xx_ReadPage(self, *args):
        """
        ntag2xx_ReadPage(PN532 self, uint8_t page, uint8_t * buffer) -> bool

        Parameters:
            page: uint8_t
            buffer: uint8_t *


        bool
        ntag2xx_ReadPage(uint8_t page, uint8_t *buffer)

        read an entire 4-byte page at the specified address

        Parameters:
        -----------

        page:  The page number (0..63 in most cases)

        buffer:  Pointer to the byte array that will hold the retrieved data
        (if any)

        true if everything executed properly, false for an error  Tries to
        read an entire 4-byte page at the specified address.

        Parameters:
        -----------

        page:  The page number (0..63 in most cases)

        buffer:  Pointer to the byte array that will hold the retrieved data
        (if any) 
        """
        return _pyupm_pn532.PN532_ntag2xx_ReadPage(self, *args)

    def ntag2xx_WritePage(self, *args):
        """
        ntag2xx_WritePage(PN532 self, uint8_t page, uint8_t * data) -> bool

        Parameters:
            page: uint8_t
            data: uint8_t *


        bool
        ntag2xx_WritePage(uint8_t page, uint8_t *data)

        write an entire 4-byte page at the specified block address

        Parameters:
        -----------

        page:  The page number to write. (0..63 for most cases)

        data:  The byte array that contains the data to write. Should be
        exactly 4 bytes long.

        true if everything executed properly, false for an error  Tries to
        write an entire 4-byte page at the specified block address.

        Parameters:
        -----------

        page:  The page number to write. (0..63 for most cases)

        data:  The byte array that contains the data to write. Should be
        exactly 4 bytes long.

        1 if everything executed properly, 0 for an error 
        """
        return _pyupm_pn532.PN532_ntag2xx_WritePage(self, *args)

    def ntag2xx_WriteNDEFURI(self, *args):
        """
        ntag2xx_WriteNDEFURI(PN532 self, upm::PN532::NDEF_URI_T uriIdentifier, char * url, uint8_t dataLen) -> bool

        Parameters:
            uriIdentifier: enum upm::PN532::NDEF_URI_T
            url: char *
            dataLen: uint8_t


        bool
        ntag2xx_WriteNDEFURI(NDEF_URI_T uriIdentifier, char *url, uint8_t
        dataLen)

        writes an NDEF URI Record starting at the specified page (4..nn)

        Note that this function assumes that the NTAG2xx card is already
        formatted to work as an "NFC Forum Tag".

        Parameters:
        -----------

        uriIdentifier:  The uri identifier code (one of the NDEF_URI_T values

        url:  The uri text to write (null-terminated string).

        dataLen:  The size of the data area for overflow checks.

        true if everything executed properly, false for an error  Writes an
        NDEF URI Record starting at the specified page (4..nn)

        Note that this function assumes that the NTAG2xx card is already
        formatted to work as an "NFC Forum Tag".

        Parameters:
        -----------

        uriIdentifier:  The uri identifier code (0 = none, 0x01 =
        "http://www.", etc.)

        url:  The uri text to write (null-terminated string).

        dataLen:  The size of the data area for overflow checks.

        1 if everything executed properly, 0 for an error 
        """
        return _pyupm_pn532.PN532_ntag2xx_WriteNDEFURI(self, *args)

    def getATQA(self):
        """
        getATQA(PN532 self) -> uint16_t

        Parameters:
            self: upm::PN532 *


        uint16_t getATQA()

        return the ATQA (Answer to Request Acknowlege) value. This value is
        only valid after a successfull call to readPassiveTargetID()

        ATQA value 
        """
        return _pyupm_pn532.PN532_getATQA(self)

    def getSAK(self):
        """
        getSAK(PN532 self) -> uint8_t

        Parameters:
            self: upm::PN532 *


        uint8_t getSAK()

        return the SAK (Select Acknowlege) value. This value is only valid
        after a successfull call to readPassiveTargetID()

        SAK value 
        """
        return _pyupm_pn532.PN532_getSAK(self)

    def i2cContext(self):
        """
        i2cContext(PN532 self) -> mraa::I2c &

        Parameters:
            self: upm::PN532 *


        mraa::I2c&
        i2cContext()

        provide public access to the class's MRAA i2C context for direct user
        access

        a reference to the class i2c context 
        """
        return _pyupm_pn532.PN532_i2cContext(self)

    def pn532Debug(self, *args):
        """
        pn532Debug(PN532 self, bool enable)

        Parameters:
            enable: bool


        void pn532Debug(bool
        enable)

        enable or disable debugging output for pn532 related operations

        Parameters:
        -----------

        enable:  true to enabloe debug output, false to disable 
        """
        return _pyupm_pn532.PN532_pn532Debug(self, *args)

    def mifareDebug(self, *args):
        """
        mifareDebug(PN532 self, bool enable)

        Parameters:
            enable: bool


        void mifareDebug(bool
        enable)

        enable or disable debugging output for mifare related operations

        Parameters:
        -----------

        enable:  true to enabloe debug output, false to disable 
        """
        return _pyupm_pn532.PN532_mifareDebug(self, *args)

    def tagType(self):
        """
        tagType(PN532 self) -> upm::PN532::TAG_TYPE_T

        Parameters:
            self: upm::PN532 *


        PN532::TAG_TYPE_T
        tagType()

        try to determine the tag type

        one of the TAG_TYPE_T values 
        """
        return _pyupm_pn532.PN532_tagType(self)

PN532_swigregister = _pyupm_pn532.PN532_swigregister
PN532_swigregister(PN532)

# This file is compatible with both classic and new-style classes.


