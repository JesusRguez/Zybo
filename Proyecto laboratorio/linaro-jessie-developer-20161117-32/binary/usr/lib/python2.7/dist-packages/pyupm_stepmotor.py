# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_stepmotor', [dirname(__file__)])
        except ImportError:
            import _pyupm_stepmotor
            return _pyupm_stepmotor
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_stepmotor', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_stepmotor = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_stepmotor
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


OVERHEAD_US = _pyupm_stepmotor.OVERHEAD_US
MINPULSE_US = _pyupm_stepmotor.MINPULSE_US
HIGH = _pyupm_stepmotor.HIGH
LOW = _pyupm_stepmotor.LOW
class StepMotor(_object):
    """
    API for the Stepper Motor.

    ID: stepmotor

    Name: Stepper Motor

    Other Names: EasyDriver Stepper Motor Driver

    Category: motor

    Manufacturer: sparkfun generic

    Link:http://www.schmalzhaus.com/EasyDriver/index.html

    Connection: gpio  This module defines the Stepper Motor interface. It
    is compatible with stepper motor drivers that use 2 pins to control
    the motor, like an Easy Driver from Brian Schmalz or the STR driver
    series from Applied Motion. It can also control an enable pin if one
    is available and connected.

    The implementation is synchronous and thus blocking while the stepper
    motor is in motion. However it is possible to send the commands via
    threading and the performance of the library will be very good given a
    low CPU load. On a busy system though you will notice some jitter
    especially at higher speeds. It is possible to reduce this effect to
    some extent by using smoothing and/or microstepping on stepper drivers
    that support such features.

    EasyDriver Sensor image provided by SparkFun* underCC BY-NC-SA-3.0.

    C++ includes: stepmotor.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StepMotor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StepMotor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::StepMotor self, int dirPin, int stePin, int steps=200, int enPin=-1) -> StepMotor

        Parameters:
            dirPin: int
            stePin: int
            steps: int
            enPin: int

        __init__(upm::StepMotor self, int dirPin, int stePin, int steps=200) -> StepMotor

        Parameters:
            dirPin: int
            stePin: int
            steps: int

        __init__(upm::StepMotor self, int dirPin, int stePin) -> StepMotor

        Parameters:
            dirPin: int
            stePin: int


        StepMotor(int
        dirPin, int stePin, int steps=200, int enPin=-1)

        Instantiates a StepMotor object.

        Parameters:
        -----------

        dirPin:  Direction GPIO pin

        stePin:  Stepper pulse GPIO pin

        steps:  Number of steps per revolution (Default 200)

        enPin:  Enable pin if connected (Optional) 
        """
        this = _pyupm_stepmotor.new_StepMotor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_stepmotor.delete_StepMotor
    __del__ = lambda self : None;
    def enable(self, *args):
        """
        enable(StepMotor self, bool flag)

        Parameters:
            flag: bool


        void enable(bool flag)

        Can be used to enable/disable the stepper driver if an enable pin is
        available and connected. Check your data sheet as some drivers might
        have the enable logic inverted.

        Parameters:
        -----------

        flag:  true to enable or false to disable 
        """
        return _pyupm_stepmotor.StepMotor_enable(self, *args)

    def setSpeed(self, *args):
        """
        setSpeed(StepMotor self, int speed)

        Parameters:
            speed: int


        void setSpeed(int
        speed)

        Sets the rotation speed in rpm. Default 60 rpm.

        Parameters:
        -----------

        speed:  Rotation speed in rpm 
        """
        return _pyupm_stepmotor.StepMotor_setSpeed(self, *args)

    def step(self, *args):
        """
        step(StepMotor self, int ticks) -> mraa::Result

        Parameters:
            ticks: int


        mraa::Result step(int
        ticks)

        Rotates the motor by the specified number of steps. Positive values
        rotate clockwise and negative values rotate counter-clockwise.

        Parameters:
        -----------

        ticks:  Number of steps the motor moves 
        """
        return _pyupm_stepmotor.StepMotor_step(self, *args)

    def stepForward(self, *args):
        """
        stepForward(StepMotor self, int ticks) -> mraa::Result

        Parameters:
            ticks: int


        mraa::Result
        stepForward(int ticks)

        Rotates the motor forward (clockwise).

        Parameters:
        -----------

        ticks:  Number of steps the motor moves 
        """
        return _pyupm_stepmotor.StepMotor_stepForward(self, *args)

    def stepBackward(self, *args):
        """
        stepBackward(StepMotor self, int ticks) -> mraa::Result

        Parameters:
            ticks: int


        mraa::Result
        stepBackward(int ticks)

        Rotates the motor backward (counter-clockwise).

        Parameters:
        -----------

        ticks:  Number of steps the motor moves 
        """
        return _pyupm_stepmotor.StepMotor_stepBackward(self, *args)

    def setPosition(self, *args):
        """
        setPosition(StepMotor self, int pos)

        Parameters:
            pos: int


        void
        setPosition(int pos)

        Sets the current position. Useful if the motor is not at 0 when the
        driver is initialized.

        Parameters:
        -----------

        step:  Current position 
        """
        return _pyupm_stepmotor.StepMotor_setPosition(self, *args)

    def getPosition(self):
        """
        getPosition(StepMotor self) -> int

        Parameters:
            self: upm::StepMotor *


        int getPosition()

        Gets the current position. This is cumulative and the result of all
        the step commands sent to the motor.

        Stepper's position. 
        """
        return _pyupm_stepmotor.StepMotor_getPosition(self)

    def getStep(self):
        """
        getStep(StepMotor self) -> int

        Parameters:
            self: upm::StepMotor *


        int getStep()

        Gets the current step. This is relative to one revolution.

        Current step, ranges from 0 to number of steps per revolution. 
        """
        return _pyupm_stepmotor.StepMotor_getStep(self)

StepMotor_swigregister = _pyupm_stepmotor.StepMotor_swigregister
StepMotor_swigregister(StepMotor)

# This file is compatible with both classic and new-style classes.


