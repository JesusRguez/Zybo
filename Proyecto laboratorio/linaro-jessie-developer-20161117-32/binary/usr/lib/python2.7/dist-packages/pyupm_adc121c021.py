# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_adc121c021', [dirname(__file__)])
        except ImportError:
            import _pyupm_adc121c021
            return _pyupm_adc121c021
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_adc121c021', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_adc121c021 = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_adc121c021
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


ADC121C021_I2C_BUS = _pyupm_adc121c021.ADC121C021_I2C_BUS
ADC121C021_DEFAULT_I2C_ADDR = _pyupm_adc121c021.ADC121C021_DEFAULT_I2C_ADDR
ADC121C021_RESOLUTION = _pyupm_adc121c021.ADC121C021_RESOLUTION
ADC121C021_REG_RESULT = _pyupm_adc121c021.ADC121C021_REG_RESULT
ADC121C021_REG_ALERT_STATUS = _pyupm_adc121c021.ADC121C021_REG_ALERT_STATUS
ADC121C021_REG_CONFIG = _pyupm_adc121c021.ADC121C021_REG_CONFIG
ADC121C021_REG_ALERT_LIM_UNDER = _pyupm_adc121c021.ADC121C021_REG_ALERT_LIM_UNDER
ADC121C021_REG_ALERT_LIM_OVER = _pyupm_adc121c021.ADC121C021_REG_ALERT_LIM_OVER
ADC121C021_REG_ALERT_HYS = _pyupm_adc121c021.ADC121C021_REG_ALERT_HYS
ADC121C021_REG_LOWEST_CONV = _pyupm_adc121c021.ADC121C021_REG_LOWEST_CONV
ADC121C021_REG_HIGHEST_CONV = _pyupm_adc121c021.ADC121C021_REG_HIGHEST_CONV
ADC121C021_DEFAULT_VREF = _pyupm_adc121c021.ADC121C021_DEFAULT_VREF
ADC121C021_CYCLE_NONE = _pyupm_adc121c021.ADC121C021_CYCLE_NONE
ADC121C021_CYCLE_32 = _pyupm_adc121c021.ADC121C021_CYCLE_32
ADC121C021_CYCLE_64 = _pyupm_adc121c021.ADC121C021_CYCLE_64
ADC121C021_CYCLE_128 = _pyupm_adc121c021.ADC121C021_CYCLE_128
ADC121C021_CYCLE_256 = _pyupm_adc121c021.ADC121C021_CYCLE_256
ADC121C021_CYCLE_512 = _pyupm_adc121c021.ADC121C021_CYCLE_512
ADC121C021_CYCLE_1024 = _pyupm_adc121c021.ADC121C021_CYCLE_1024
ADC121C021_CYCLE_2048 = _pyupm_adc121c021.ADC121C021_CYCLE_2048
class ADC121C021(_object):
    """
    API for the ADC121C021 I2C Analog-to-Digital Converter.

    ID: adc121c021

    Name: ADC121C021 Analog-to-Digital Converter

    Other Names: Grove I2C ADC

    Category: electric

    Manufacturer: seeed

    Link:http://www.seeedstudio.com/depot/Grove-I2C-ADC-p-1580.html

    Connection: i2c  UPM module for the ADC121C021 12-bit analog-to-
    digital converter (ADC). By constantly providing a reference voltage,
    this sensor helps increase the accuracy of a value collected from an
    analog sensor.

    C++ includes: adc121c021.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ADC121C021, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ADC121C021, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::ADC121C021 self, int bus, uint8_t address=0x55, float vref=3.0) -> ADC121C021

        Parameters:
            bus: int
            address: uint8_t
            vref: float

        __init__(upm::ADC121C021 self, int bus, uint8_t address=0x55) -> ADC121C021

        Parameters:
            bus: int
            address: uint8_t

        __init__(upm::ADC121C021 self, int bus) -> ADC121C021

        Parameters:
            bus: int


        ADC121C021(int
        bus, uint8_t address=ADC121C021_DEFAULT_I2C_ADDR, float
        vref=ADC121C021_DEFAULT_VREF)

        ADC121C021 ADC constructor

        Parameters:
        -----------

        bus:  I2C bus to use

        address:  Address for this sensor; default is 0x55

        vref:  Reference voltage for this sensor; default is 3.0v 
        """
        this = _pyupm_adc121c021.new_ADC121C021(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_adc121c021.delete_ADC121C021
    __del__ = lambda self : None;
    def writeByte(self, *args):
        """
        writeByte(ADC121C021 self, uint8_t reg, uint8_t byte) -> mraa_result_t

        Parameters:
            reg: uint8_t
            byte: uint8_t


        mraa_result_t
        writeByte(uint8_t reg, uint8_t byte)

        Writes a byte value into the register

        Parameters:
        -----------

        reg:  Register location to write into

        byte:  Byte to write

        0 (MRAA_SUCCESS) if successful; non-zero otherwise 
        """
        return _pyupm_adc121c021.ADC121C021_writeByte(self, *args)

    def writeWord(self, *args):
        """
        writeWord(ADC121C021 self, uint8_t reg, uint16_t word) -> mraa_result_t

        Parameters:
            reg: uint8_t
            word: uint16_t


        mraa_result_t
        writeWord(uint8_t reg, uint16_t word)

        Writes a word value into the register

        Parameters:
        -----------

        reg:  Register location to write into

        word:  Word to write

        0 (MRAA_SUCCESS) if successful; non-zero otherwise 
        """
        return _pyupm_adc121c021.ADC121C021_writeWord(self, *args)

    def readByte(self, *args):
        """
        readByte(ADC121C021 self, uint8_t reg) -> uint8_t

        Parameters:
            reg: uint8_t


        uint8_t
        readByte(uint8_t reg)

        Reads the byte value from the register

        Parameters:
        -----------

        reg:  Register location to read from

        Value in the specified register 
        """
        return _pyupm_adc121c021.ADC121C021_readByte(self, *args)

    def readWord(self, *args):
        """
        readWord(ADC121C021 self, uint8_t reg) -> uint16_t

        Parameters:
            reg: uint8_t


        uint16_t
        readWord(uint8_t reg)

        Reads the word value from the register

        Parameters:
        -----------

        reg:  Register location to read from

        Value in the specified register 
        """
        return _pyupm_adc121c021.ADC121C021_readWord(self, *args)

    def value(self):
        """
        value(ADC121C021 self) -> uint16_t

        Parameters:
            self: upm::ADC121C021 *


        uint16_t value()

        Reads the current value of conversion

        Current value of conversion 
        """
        return _pyupm_adc121c021.ADC121C021_value(self)

    def valueToVolts(self, *args):
        """
        valueToVolts(ADC121C021 self, uint16_t val) -> float

        Parameters:
            val: uint16_t


        float
        valueToVolts(uint16_t val)

        Converts a supplied value to voltage based on the set vref

        Parameters:
        -----------

        val:  Value of conversion (from value())

        Value of conversion in volts 
        """
        return _pyupm_adc121c021.ADC121C021_valueToVolts(self, *args)

    def getAlertStatus(self):
        """
        getAlertStatus(ADC121C021 self) -> bool

        Parameters:
            self: upm::ADC121C021 *


        bool
        getAlertStatus()

        Reads the current status of the alert flag. If the flag is set, the
        low or high alert indicators are set as appropriate, and you can
        access these values with alertLowTriggered() or alertHighTriggered().

        True if the alert flag is set 
        """
        return _pyupm_adc121c021.ADC121C021_getAlertStatus(self)

    def alertLowTriggered(self):
        """
        alertLowTriggered(ADC121C021 self) -> bool

        Parameters:
            self: upm::ADC121C021 *


        bool
        alertLowTriggered()

        Returns the current value of m_alertLow. You must call
        getAlertStatus() to update this value.

        Current status of the alert low flag 
        """
        return _pyupm_adc121c021.ADC121C021_alertLowTriggered(self)

    def alertHighTriggered(self):
        """
        alertHighTriggered(ADC121C021 self) -> bool

        Parameters:
            self: upm::ADC121C021 *


        bool
        alertHighTriggered()

        Returns the current value of m_alertHigh. You must call
        getAlertStatus() to update this value.

        Current status of the alert high flag 
        """
        return _pyupm_adc121c021.ADC121C021_alertHighTriggered(self)

    def clearAlertStatus(self):
        """
        clearAlertStatus(ADC121C021 self)

        Parameters:
            self: upm::ADC121C021 *


        void
        clearAlertStatus()

        Clears the alert low and alert high flags. This also clears the last
        stored alert values. 
        """
        return _pyupm_adc121c021.ADC121C021_clearAlertStatus(self)

    def enableAlertFlag(self, *args):
        """
        enableAlertFlag(ADC121C021 self, bool enable)

        Parameters:
            enable: bool


        void
        enableAlertFlag(bool enable)

        Enables or disables the alert flag functionality. If enabled, when the
        measured value exceeds the low or high limits configured, the alert
        flag is set. Use getAlertStatus() to access these values.

        Parameters:
        -----------

        enable:  If true, enables the alert flag; otherwise, disables the
        alert flag 
        """
        return _pyupm_adc121c021.ADC121C021_enableAlertFlag(self, *args)

    def enableAlertPin(self, *args):
        """
        enableAlertPin(ADC121C021 self, bool enable)

        Parameters:
            enable: bool


        void
        enableAlertPin(bool enable)

        Enables or disables the alert pin functionality.

        Parameters:
        -----------

        enable:  If true, enables the alert pin; otherwise, disables the alert
        pin 
        """
        return _pyupm_adc121c021.ADC121C021_enableAlertPin(self, *args)

    def enableAlertHold(self, *args):
        """
        enableAlertHold(ADC121C021 self, bool enable)

        Parameters:
            enable: bool


        void
        enableAlertHold(bool enable)

        Enables or disables the alert hold functionality. When the alert hold
        is enabled, the alert status remains until manually cleared via
        clearAlertStatus(). Otherwise, the alert self-clears when the value
        moves into the defined limits if alerts are enabled via
        enableAlertFlag().

        Parameters:
        -----------

        enable:  If true, enables the alert hold; otherwise, disables the
        alert hold 
        """
        return _pyupm_adc121c021.ADC121C021_enableAlertHold(self, *args)

    def enableAlertPinPolarityHigh(self, *args):
        """
        enableAlertPinPolarityHigh(ADC121C021 self, bool enable)

        Parameters:
            enable: bool


        void enableAlertPinPolarityHigh(bool enable)

        If the alert pin is enabled, defines the active polarity of the pin in
        an alert condition. Enabling this sets the pin to active high in an
        alert condition; otherwise, active low is used.

        Parameters:
        -----------

        enable:  If true, the alert pin is active high; otherwise, active low

        """
        return _pyupm_adc121c021.ADC121C021_enableAlertPinPolarityHigh(self, *args)

    def setAutomaticConversion(self, *args):
        """
        setAutomaticConversion(ADC121C021 self, upm::ADC121C021_CYCLE_TIME_T cycleTime)

        Parameters:
            cycleTime: enum upm::ADC121C021_CYCLE_TIME_T


        void
        setAutomaticConversion(ADC121C021_CYCLE_TIME_T cycleTime)

        Enables or disables the automatic conversion mode. When enabled, the
        ADC samples and updates the conversion value independently. It is
        disabled by default, so conversion is only done by calling value().

        Parameters:
        -----------

        cycleTime:  Sets the cycle time for automatic conversion 
        """
        return _pyupm_adc121c021.ADC121C021_setAutomaticConversion(self, *args)

    def setAlertLowLimit(self, *args):
        """
        setAlertLowLimit(ADC121C021 self, uint16_t limit) -> mraa_result_t

        Parameters:
            limit: uint16_t


        mraa_result_t setAlertLowLimit(uint16_t limit)

        Sets the alert low limit. If alerts are enabled and the measured
        conversion value is lower than the low limit, an alert is triggered.

        Parameters:
        -----------

        limit:  Alert low limit

        0 (MRAA_SUCCESS) if successful; non-zero otherwise 
        """
        return _pyupm_adc121c021.ADC121C021_setAlertLowLimit(self, *args)

    def setAlertHighLimit(self, *args):
        """
        setAlertHighLimit(ADC121C021 self, uint16_t limit) -> mraa_result_t

        Parameters:
            limit: uint16_t


        mraa_result_t setAlertHighLimit(uint16_t limit)

        Sets the alert high limit. If alerts are enabled and the measured
        conversion value is higher than the high limit, an alert is triggered.

        Parameters:
        -----------

        limit:  Alert high limit

        0 (MRAA_SUCCESS) if successful; non-zero otherwise 
        """
        return _pyupm_adc121c021.ADC121C021_setAlertHighLimit(self, *args)

    def setHysteresis(self, *args):
        """
        setHysteresis(ADC121C021 self, uint16_t limit) -> mraa_result_t

        Parameters:
            limit: uint16_t


        mraa_result_t
        setHysteresis(uint16_t limit)

        Sets the hysteresis value. If a high or low alert condition is
        triggered, the conversion result must move within the high or low
        limit by more than this value to clear the alert condition. If the
        alert hold is set, the alert doesn't self-clear regardless of this
        value.

        Parameters:
        -----------

        limit:  Hysteresis limit

        0 (MRAA_SUCCESS) if successful; non-zero otherwise 
        """
        return _pyupm_adc121c021.ADC121C021_setHysteresis(self, *args)

    def getHighestConversion(self):
        """
        getHighestConversion(ADC121C021 self) -> uint16_t

        Parameters:
            self: upm::ADC121C021 *


        uint16_t getHighestConversion()

        Returns the highest conversion value recorded so far. This value is
        only updated by the converter when the automatic conversion mode is
        enabled.

        Highest conversion value 
        """
        return _pyupm_adc121c021.ADC121C021_getHighestConversion(self)

    def getLowestConversion(self):
        """
        getLowestConversion(ADC121C021 self) -> uint16_t

        Parameters:
            self: upm::ADC121C021 *


        uint16_t
        getLowestConversion()

        Returns the lowest conversion value recorded so far. This value is
        only updated by the converter when the automatic conversion mode is
        enabled.

        Lowest conversion value 
        """
        return _pyupm_adc121c021.ADC121C021_getLowestConversion(self)

    def clearHighestConversion(self):
        """
        clearHighestConversion(ADC121C021 self) -> mraa_result_t

        Parameters:
            self: upm::ADC121C021 *


        mraa_result_t clearHighestConversion()

        Clears the highest conversion value recorded so far.

        0 (MRAA_SUCCESS) if successful; non-zero otherwise 
        """
        return _pyupm_adc121c021.ADC121C021_clearHighestConversion(self)

    def clearLowestConversion(self):
        """
        clearLowestConversion(ADC121C021 self) -> mraa_result_t

        Parameters:
            self: upm::ADC121C021 *


        mraa_result_t clearLowestConversion()

        Clears the lowest conversion value recorded so far.

        0 (MRAA_SUCCESS) if successful; non-zero otherwise 
        """
        return _pyupm_adc121c021.ADC121C021_clearLowestConversion(self)

ADC121C021_swigregister = _pyupm_adc121c021.ADC121C021_swigregister
ADC121C021_swigregister(ADC121C021)

# This file is compatible with both classic and new-style classes.


