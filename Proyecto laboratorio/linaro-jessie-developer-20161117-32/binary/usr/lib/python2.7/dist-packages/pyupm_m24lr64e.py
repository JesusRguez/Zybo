# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_m24lr64e', [dirname(__file__)])
        except ImportError:
            import _pyupm_m24lr64e
            return _pyupm_m24lr64e
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_m24lr64e', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_m24lr64e = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_m24lr64e
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


M24LR64E_I2C_BUS = _pyupm_m24lr64e.M24LR64E_I2C_BUS
M24LR64E_DEFAULT_I2C_ADDR = _pyupm_m24lr64e.M24LR64E_DEFAULT_I2C_ADDR
M24LR64E_DEFAULT_I2C_ADDR_E2 = _pyupm_m24lr64e.M24LR64E_DEFAULT_I2C_ADDR_E2
class M24LR64E(_object):
    """
    C++ API for the M24LR64E-based Grove NFC Tag.

    ID: m24lr64e

    Name: Grove NFC Tag

    Category: other

    Manufacturer: seeed

    Link:http://www.seeedstudio.com/wiki/Grove_-_NFC_Tag

    Connection: i2c  Grove NFC tag is an 8KB electrically erasable
    programmable read-only memory (EEPROM) that can be written to or read
    from using I2C and NFC- equipped devices.

    The user mode (default) allows read and write access to all 8KB of
    space, provided the sector security status (SSS) allows it. The root
    mode allows modification of the SSS data and other information,
    provided the proper password is submitted. The default password for a
    new tag is 0x00000000. See the datasheet for more details.

    The Seeed Studio* wiki page for this device includes a link to an
    Android* application that can be used to also read and write the
    device via NFC, as well as set NFC passwords, which cannot be done via
    I2C.

    C++ includes: m24lr64e.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, M24LR64E, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, M24LR64E, name)
    __repr__ = _swig_repr
    EEPROM_I2C_LENGTH = _pyupm_m24lr64e.M24LR64E_EEPROM_I2C_LENGTH
    PASSWORD_LENGTH = _pyupm_m24lr64e.M24LR64E_PASSWORD_LENGTH
    SECTOR_SECURITY_STATUS_BASE_ADDR = _pyupm_m24lr64e.M24LR64E_SECTOR_SECURITY_STATUS_BASE_ADDR
    LOCK_PROTECT_BIT = _pyupm_m24lr64e.M24LR64E_LOCK_PROTECT_BIT
    WRITE_READ_PROTECT_BIT = _pyupm_m24lr64e.M24LR64E_WRITE_READ_PROTECT_BIT
    PASSWORD_CTRL_BIT = _pyupm_m24lr64e.M24LR64E_PASSWORD_CTRL_BIT
    UID_LENGTH = _pyupm_m24lr64e.M24LR64E_UID_LENGTH
    I2C_WRITE_TIME = _pyupm_m24lr64e.M24LR64E_I2C_WRITE_TIME
    I2C_PASSWORD_ADDR = _pyupm_m24lr64e.M24LR64E_I2C_PASSWORD_ADDR
    RF_PASSWORD_1_ADDR = _pyupm_m24lr64e.M24LR64E_RF_PASSWORD_1_ADDR
    RF_PASSWORD_2_ADDR = _pyupm_m24lr64e.M24LR64E_RF_PASSWORD_2_ADDR
    RF_PASSWORD_3_ADDR = _pyupm_m24lr64e.M24LR64E_RF_PASSWORD_3_ADDR
    DSFID_ADDR = _pyupm_m24lr64e.M24LR64E_DSFID_ADDR
    AFI_ADDR = _pyupm_m24lr64e.M24LR64E_AFI_ADDR
    RESV_ADDR = _pyupm_m24lr64e.M24LR64E_RESV_ADDR
    CONFIG_ADDR = _pyupm_m24lr64e.M24LR64E_CONFIG_ADDR
    UID_ADDR = _pyupm_m24lr64e.M24LR64E_UID_ADDR
    MEM_SIZE_ADDR = _pyupm_m24lr64e.M24LR64E_MEM_SIZE_ADDR
    IC_REF_ADDR = _pyupm_m24lr64e.M24LR64E_IC_REF_ADDR
    PROG_COMP_ENERGY_HARVEST_ADDR = _pyupm_m24lr64e.M24LR64E_PROG_COMP_ENERGY_HARVEST_ADDR
    USER_MODE = _pyupm_m24lr64e.M24LR64E_USER_MODE
    ROOT_MODE = _pyupm_m24lr64e.M24LR64E_ROOT_MODE
    Access_1110 = _pyupm_m24lr64e.M24LR64E_Access_1110
    Access_1111 = _pyupm_m24lr64e.M24LR64E_Access_1111
    Access_1100 = _pyupm_m24lr64e.M24LR64E_Access_1100
    Access_0111 = _pyupm_m24lr64e.M24LR64E_Access_0111
    noPasswd = _pyupm_m24lr64e.M24LR64E_noPasswd
    passwd_1 = _pyupm_m24lr64e.M24LR64E_passwd_1
    passwd_2 = _pyupm_m24lr64e.M24LR64E_passwd_2
    passwd_3 = _pyupm_m24lr64e.M24LR64E_passwd_3
    def __init__(self, *args): 
        """
        __init__(upm::M24LR64E self, int bus, upm::M24LR64E::AccessMode mode=USER_MODE) -> M24LR64E

        Parameters:
            bus: int
            mode: enum upm::M24LR64E::AccessMode

        __init__(upm::M24LR64E self, int bus) -> M24LR64E

        Parameters:
            bus: int


        M24LR64E(int bus,
        AccessMode mode=USER_MODE)

        M24LR64E constructor

        Parameters:
        -----------

        bus:  I2C bus to use

        mode:  Access mode (user or root) to use 
        """
        this = _pyupm_m24lr64e.new_M24LR64E(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_m24lr64e.delete_M24LR64E
    __del__ = lambda self : None;
    def submitPasswd(self, *args):
        """
        submitPasswd(M24LR64E self, uint32_t passwd) -> bool

        Parameters:
            passwd: uint32_t


        bool
        submitPasswd(uint32_t passwd)

        Submits an I2C access password

        Parameters:
        -----------

        passwd:  4-byte access password 
        """
        return _pyupm_m24lr64e.M24LR64E_submitPasswd(self, *args)

    def writePasswd(self, *args):
        """
        writePasswd(M24LR64E self, uint32_t passwd) -> bool

        Parameters:
            passwd: uint32_t


        bool
        writePasswd(uint32_t passwd)

        Writes a new I2C password

        Parameters:
        -----------

        passwd:  4-byte access password 
        """
        return _pyupm_m24lr64e.M24LR64E_writePasswd(self, *args)

    def sectorProtectConfig(self, *args):
        """
        sectorProtectConfig(M24LR64E self, unsigned int sectorNumber, bool protectEnable, upm::M24LR64E::SectorAccessRight accessRight, 
            upm::M24LR64E::SectorSelectPassWd passwd)

        Parameters:
            sectorNumber: unsigned int
            protectEnable: bool
            accessRight: enum upm::M24LR64E::SectorAccessRight
            passwd: enum upm::M24LR64E::SectorSelectPassWd


        void
        sectorProtectConfig(unsigned int sectorNumber, bool protectEnable,
        SectorAccessRight accessRight, SectorSelectPassWd passwd)

        Sets a protection bit for a sector. Must be in the root mode

        Parameters:
        -----------

        sectorNumber:  Sector whose protection you are modifying

        protectEnable:  True if you are enabling protection

        accessRight:  Access rights to set

        passwd:  Password number to enable, if any 
        """
        return _pyupm_m24lr64e.M24LR64E_sectorProtectConfig(self, *args)

    def clearSectorProtect(self):
        """
        clearSectorProtect(M24LR64E self)

        Parameters:
            self: upm::M24LR64E *


        void
        clearSectorProtect(void)

        Clears sector protection bits. Must be in the root mode. 
        """
        return _pyupm_m24lr64e.M24LR64E_clearSectorProtect(self)

    def sectorWriteLockBit(self, *args):
        """
        sectorWriteLockBit(M24LR64E self, unsigned int sectorNumber, bool sockEnable)

        Parameters:
            sectorNumber: unsigned int
            sockEnable: bool


        void
        sectorWriteLockBit(unsigned int sectorNumber, bool sockEnable)

        Sets or clears a sector security status lock bit for a sector. Must be
        in the root mode.

        Parameters:
        -----------

        sectorNumber:  Sector whose SSS you want to modify

        sockEnable:  True to set the bit, false to clear it 
        """
        return _pyupm_m24lr64e.M24LR64E_sectorWriteLockBit(self, *args)

    def getDSFID(self):
        """
        getDSFID(M24LR64E self) -> uint8_t

        Parameters:
            self: upm::M24LR64E *


        uint8_t getDSFID()

        Returns a data storage family identifier (DSFID) Must be in the root
        mode.

        DSFID 
        """
        return _pyupm_m24lr64e.M24LR64E_getDSFID(self)

    def getAFI(self):
        """
        getAFI(M24LR64E self) -> uint8_t

        Parameters:
            self: upm::M24LR64E *


        uint8_t getAFI()

        Returns an application family identifier (AFI) Must be in the root
        mode.

        AFI 
        """
        return _pyupm_m24lr64e.M24LR64E_getAFI(self)

    def getUID(self):
        """
        getUID(M24LR64E self) -> uint8_t *

        Parameters:
            self: upm::M24LR64E *


        uint8_t * getUID()

        Returns a unique ID. Must be in the root mode. Maintained to preserve
        compatibility with older code.

        buf Buffer to hold the UID. Must be UID_LENGTH bytes. 
        """
        return _pyupm_m24lr64e.M24LR64E_getUID(self)

    def getMemorySize(self):
        """
        getMemorySize(M24LR64E self) -> uint32_t

        Parameters:
            self: upm::M24LR64E *


        uint32_t
        getMemorySize()

        Returns the memory size Must be in the root mode.

        Amount of memory present 
        """
        return _pyupm_m24lr64e.M24LR64E_getMemorySize(self)

    def clearMemory(self):
        """
        clearMemory(M24LR64E self)

        Parameters:
            self: upm::M24LR64E *


        void clearMemory()

        Sets all memory to 0, if permissions allow 
        """
        return _pyupm_m24lr64e.M24LR64E_clearMemory(self)

    def writeByte(self, *args):
        """
        writeByte(M24LR64E self, unsigned int address, uint8_t data) -> mraa::Result

        Parameters:
            address: unsigned int
            data: uint8_t


        mraa::Result
        writeByte(unsigned int address, uint8_t data)

        Writes a byte to the EEPROM

        Parameters:
        -----------

        address:  Address to write to

        data:  Data to write 
        """
        return _pyupm_m24lr64e.M24LR64E_writeByte(self, *args)

    def writeBytes(self, *args):
        """
        writeBytes(M24LR64E self, unsigned int address, uint8_t * buffer, int len) -> mraa::Result

        Parameters:
            address: unsigned int
            buffer: uint8_t *
            len: int


        mraa::Result
        writeBytes(unsigned int address, uint8_t *buffer, int len)

        Writes bytes to the EEPROM

        Parameters:
        -----------

        address:  Address to write to

        data:  Data to write

        data:  Length of the data buffer 
        """
        return _pyupm_m24lr64e.M24LR64E_writeBytes(self, *args)

    def readByte(self, *args):
        """
        readByte(M24LR64E self, unsigned int address) -> uint8_t

        Parameters:
            address: unsigned int


        uint8_t
        readByte(unsigned int address)

        Reads a byte from the EEPROM

        Parameters:
        -----------

        address:  Address to read from

        data Value read 
        """
        return _pyupm_m24lr64e.M24LR64E_readByte(self, *args)

    def readBytes(self, *args):
        """
        readBytes(M24LR64E self, unsigned int address, uint8_t * buffer, int len) -> int

        Parameters:
            address: unsigned int
            buffer: uint8_t *
            len: int


        int
        readBytes(unsigned int address, uint8_t *buffer, int len)

        Reads multiple bytes from the EEPROM

        Parameters:
        -----------

        address:  Address to read from

        buffer:  Buffer to store data

        len:  Number of bytes to read 
        """
        return _pyupm_m24lr64e.M24LR64E_readBytes(self, *args)

M24LR64E_swigregister = _pyupm_m24lr64e.M24LR64E_swigregister
M24LR64E_swigregister(M24LR64E)

# This file is compatible with both classic and new-style classes.


