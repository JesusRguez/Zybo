# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_mg811', [dirname(__file__)])
        except ImportError:
            import _pyupm_mg811
            return _pyupm_mg811
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_mg811', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_mg811 = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_mg811
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class MG811(_object):
    """
    API for the DFRobot CO2 Sensor.

    ID: mg811

    Name: DFRobot CO2 Sensor

    Other Names: MG811

    Category: gas

    Manufacturer: dfrobot

    Link:http://www.dfrobot.com/index.php?route=product/product&product_id=1023

    Connection: analog  This sensor returns an an analog voltage that
    falls as the concentration of CO2 increases. It contains a heater that
    must be allowed to 'warm' up the sensor before measurements are stable
    (hours to days is the recommendation). It requires that the MCU be
    powered from an external power supply (not USB) at 5v, since the
    heater will consume significant current.

    The sensor should be allowed to 'heat' up for some time before
    beginning use, typically a couple of hours minimum. It also needs
    fairly precise calibration at 400ppm and 1000ppm to return meaningful
    results.

    The sensor also incorporates a potentiometer that can be adjusted to
    specific threshold. Once that threshold is reached, an LED on the
    sensor will light, and the digital pin will be driven high.

    C++ includes: mg811.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MG811, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MG811, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::MG811 self, int pin, int dpin, float aref=5.0) -> MG811

        Parameters:
            pin: int
            dpin: int
            aref: float

        __init__(upm::MG811 self, int pin, int dpin) -> MG811

        Parameters:
            pin: int
            dpin: int


        MG811(int pin, int dpin,
        float aref=5.0)

        MG811 constructor

        Parameters:
        -----------

        pin:  Analog pin to use

        dpin:  Digital pin that indicates threshold

        aref:  Analog reference voltage; default is 5.0 V 
        """
        this = _pyupm_mg811.new_MG811(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_mg811.delete_MG811
    __del__ = lambda self : None;
    def getReferenceVoltage(self):
        """
        getReferenceVoltage(MG811 self) -> float

        Parameters:
            self: upm::MG811 *


        float
        getReferenceVoltage()

        Return a cumputed reference voltage to be used in calibration.
        Computed reference voltage 
        """
        return _pyupm_mg811.MG811_getReferenceVoltage(self)

    def setCalibration(self, *args):
        """
        setCalibration(MG811 self, float ppm400, float ppm1000)

        Parameters:
            ppm400: float
            ppm1000: float


        void
        setCalibration(float ppm400, float ppm1000)

        Set calibration parameters. You should measure the reference voltage
        you get when at CO2 concentrations of 400ppm (ambient) and 1000ppm
        using the getReferenceVoltage() method. Then specify those voltages
        here for more accurate results.

        Parameters:
        -----------

        ppm400:  The measured reference voltage at 400 ppm

        ppm40000:  The measured reference voltage at 1000 ppm 
        """
        return _pyupm_mg811.MG811_setCalibration(self, *args)

    def volts(self):
        """
        volts(MG811 self) -> float

        Parameters:
            self: upm::MG811 *


        float volts()

        Returns the voltage detected on the analog pin

        The detected voltage 
        """
        return _pyupm_mg811.MG811_volts(self)

    def ppm(self):
        """
        ppm(MG811 self) -> float

        Parameters:
            self: upm::MG811 *


        float ppm()

        Returns the computed CO2 concentration in ppm (Parts Per Million).
        This method will return 0.0 if the reference voltage is greater than
        the ppm400 value. Essentially, ppm values below 400 will be reported
        as 0.

        The computed CO2 concentration in ppm 
        """
        return _pyupm_mg811.MG811_ppm(self)

    def thresholdReached(self):
        """
        thresholdReached(MG811 self) -> bool

        Parameters:
            self: upm::MG811 *


        bool
        thresholdReached()

        Read the digital pin and return true if the set threshold has been
        reached or exceeded. This threshold is set by adjusting the
        potentiometer on the sensor.

        true if the threshold has been reached, false otherwise 
        """
        return _pyupm_mg811.MG811_thresholdReached(self)

MG811_swigregister = _pyupm_mg811.MG811_swigregister
MG811_swigregister(MG811)

# This file is compatible with both classic and new-style classes.


