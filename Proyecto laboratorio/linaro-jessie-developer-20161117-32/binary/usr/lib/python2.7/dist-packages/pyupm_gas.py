# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pyupm_gas', [dirname(__file__)])
        except ImportError:
            import _pyupm_gas
            return _pyupm_gas
        if fp is not None:
            try:
                _mod = imp.load_module('_pyupm_gas', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pyupm_gas = swig_import_helper()
    del swig_import_helper
else:
    import _pyupm_gas
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class uint16Array(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint16Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint16Array, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pyupm_gas.new_uint16Array(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_uint16Array
    __del__ = lambda self : None;
    def __getitem__(self, *args): return _pyupm_gas.uint16Array___getitem__(self, *args)
    def __setitem__(self, *args): return _pyupm_gas.uint16Array___setitem__(self, *args)
    def cast(self): return _pyupm_gas.uint16Array_cast(self)
    __swig_getmethods__["frompointer"] = lambda x: _pyupm_gas.uint16Array_frompointer
    if _newclass:frompointer = staticmethod(_pyupm_gas.uint16Array_frompointer)
uint16Array_swigregister = _pyupm_gas.uint16Array_swigregister
uint16Array_swigregister(uint16Array)

def uint16Array_frompointer(*args):
  return _pyupm_gas.uint16Array_frompointer(*args)
uint16Array_frompointer = _pyupm_gas.uint16Array_frompointer

class thresholdContext(_object):
    """Proxy of C++ thresholdContext class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, thresholdContext, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, thresholdContext, name)
    __repr__ = _swig_repr
    __swig_setmethods__["averageReading"] = _pyupm_gas.thresholdContext_averageReading_set
    __swig_getmethods__["averageReading"] = _pyupm_gas.thresholdContext_averageReading_get
    if _newclass:averageReading = _swig_property(_pyupm_gas.thresholdContext_averageReading_get, _pyupm_gas.thresholdContext_averageReading_set)
    __swig_setmethods__["runningAverage"] = _pyupm_gas.thresholdContext_runningAverage_set
    __swig_getmethods__["runningAverage"] = _pyupm_gas.thresholdContext_runningAverage_get
    if _newclass:runningAverage = _swig_property(_pyupm_gas.thresholdContext_runningAverage_get, _pyupm_gas.thresholdContext_runningAverage_set)
    __swig_setmethods__["averagedOver"] = _pyupm_gas.thresholdContext_averagedOver_set
    __swig_getmethods__["averagedOver"] = _pyupm_gas.thresholdContext_averagedOver_get
    if _newclass:averagedOver = _swig_property(_pyupm_gas.thresholdContext_averagedOver_get, _pyupm_gas.thresholdContext_averagedOver_set)
    def __init__(self): 
        """__init__(thresholdContext self) -> thresholdContext"""
        this = _pyupm_gas.new_thresholdContext()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_thresholdContext
    __del__ = lambda self : None;
thresholdContext_swigregister = _pyupm_gas.thresholdContext_swigregister
thresholdContext_swigregister(thresholdContext)

class Gas(_object):
    """Proxy of C++ upm::Gas class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Gas, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Gas, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::Gas self, int gasPin) -> Gas

        Parameters:
            gasPin: int


        Gas(int gasPin)

        Instantiates a Gas object

        Parameters:
        -----------

        gasPin:  Pin where gas is connected 
        """
        this = _pyupm_gas.new_Gas(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_Gas
    __del__ = lambda self : None;
    def getSampledWindow(self, *args):
        """
        getSampledWindow(Gas self, unsigned int freqMS, int numberOfSamples, uint16_t * buffer) -> int

        Parameters:
            freqMS: unsigned int
            numberOfSamples: int
            buffer: uint16_t *


        int
        getSampledWindow(unsigned int freqMS, int numberOfSamples, uint16_t
        *buffer)

        Gets samples from the gas sensor according to the provided window and
        number of samples

        Parameters:
        -----------

        freqMS:  Time between each sample (in milliseconds)

        numberOfSamples:  Number of sample to sample for this window

        buffer:  Buffer with sampled data 
        """
        return _pyupm_gas.Gas_getSampledWindow(self, *args)

    def findThreshold(self, *args):
        """
        findThreshold(Gas self, thresholdContext ctx, unsigned int threshold, uint16_t * buffer, int len) -> int

        Parameters:
            ctx: thresholdContext *
            threshold: unsigned int
            buffer: uint16_t *
            len: int


        int
        findThreshold(thresholdContext *ctx, unsigned int threshold, uint16_t
        *buffer, int len)

        Given the sampled buffer, this method returns TRUE/FALSE if the
        threshold is reached

        Parameters:
        -----------

        ctx:  Threshold context

        threshold:  Sample threshold

        buffer:  Buffer with samples

        len:  Buffer length 
        """
        return _pyupm_gas.Gas_findThreshold(self, *args)

    def getSampledData(self, *args):
        """
        getSampledData(Gas self, thresholdContext ctx) -> int

        Parameters:
            ctx: thresholdContext *


        int
        getSampledData(thresholdContext *ctx)

        Returns average data for the sampled window

        Parameters:
        -----------

        ctx:  Threshold context 
        """
        return _pyupm_gas.Gas_getSampledData(self, *args)

    def getSample(self):
        """
        getSample(Gas self) -> int

        Parameters:
            self: upm::Gas *


        int getSample()

        Returns one sample from the sensor 
        """
        return _pyupm_gas.Gas_getSample(self)

    def printGraph(self, *args):
        """
        printGraph(Gas self, thresholdContext ctx, uint8_t resolution)

        Parameters:
            ctx: thresholdContext *
            resolution: uint8_t


        void
        printGraph(thresholdContext *ctx, uint8_t resolution)

        Prints a running average of the threshold context

        Parameters:
        -----------

        ctx:  Threshold context 
        """
        return _pyupm_gas.Gas_printGraph(self, *args)

Gas_swigregister = _pyupm_gas.Gas_swigregister
Gas_swigregister(Gas)

class MQ2(Gas):
    """
    API for the Grove MQ2 Gas Sensor.

    ID: mq2

    Name: Grove MQ2 Gas Sensor

    Category: gaseous

    Manufacturer: seeed

    Connection: analog

    Kit: hak  The Grove MQ2 Gas Sensor module is useful for gas leakage
    detection (in home and industry). It can detect LPG, i-butane,
    methane, alcohol, hydrogen, smoke, and other combustible gases. It's a
    medium-sensitivity sensor with a detection range of 300-10,000 ppm.

    C++ includes: mq2.h 
    """
    __swig_setmethods__ = {}
    for _s in [Gas]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MQ2, name, value)
    __swig_getmethods__ = {}
    for _s in [Gas]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MQ2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::MQ2 self, int gasPin) -> MQ2

        Parameters:
            gasPin: int


        MQ2(int gasPin)

        MQ2 constructor

        Parameters:
        -----------

        gasPin:  Analog pin where the sensor is connected 
        """
        this = _pyupm_gas.new_MQ2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_MQ2
    __del__ = lambda self : None;
    def name(self):
        """
        name(MQ2 self) -> std::string

        Parameters:
            self: upm::MQ2 *


        std::string name()

        Returns the name of the sensor 
        """
        return _pyupm_gas.MQ2_name(self)

MQ2_swigregister = _pyupm_gas.MQ2_swigregister
MQ2_swigregister(MQ2)

class MQ3(Gas):
    """
    API for the MQ3 Gas Sensor.

    ID: mq3

    Name: Grove MQ3 Gas Sensor

    Category: gaseous

    Manufacturer: seeed

    Connection: analog  The Grove MQ3 Gas Sensor module is useful for gas
    leakage detection (in home and industry). It can detect alcohol vapors
    and benzine. It's highly sensitive but has a long warm-up time of
    about 1 minute. It's detection range is 0.04-4 mg/L Alcohol.

    C++ includes: mq3.h 
    """
    __swig_setmethods__ = {}
    for _s in [Gas]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MQ3, name, value)
    __swig_getmethods__ = {}
    for _s in [Gas]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MQ3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::MQ3 self, int gasPin) -> MQ3

        Parameters:
            gasPin: int


        MQ3(int gasPin)

        MQ3 constructor

        Parameters:
        -----------

        gasPin:  Analog pin where the sensor is connected 
        """
        this = _pyupm_gas.new_MQ3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_MQ3
    __del__ = lambda self : None;
    def name(self):
        """
        name(MQ3 self) -> std::string

        Parameters:
            self: upm::MQ3 *


        std::string name()

        Returns the name of the sensor 
        """
        return _pyupm_gas.MQ3_name(self)

MQ3_swigregister = _pyupm_gas.MQ3_swigregister
MQ3_swigregister(MQ3)

class MQ4(Gas):
    """
    API for the DFRobot MQ4 Gas Sensor.

    ID: mq4

    Name: DFRobot MQ4 Gas Sensor

    Category: gaseous

    Manufacturer: dfrobot

    Connection: analog  The MQ4 Gas Sensor module is useful for detecting
    CH4 (Methane), and natural gas concentrations in the air. It has a
    detection range of 100-10000 ppm.

    For optimum use, it requires calibration after a pre-heat time of at
    least 24 hours. See the datasheet for details.

    C++ includes: mq4.h 
    """
    __swig_setmethods__ = {}
    for _s in [Gas]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MQ4, name, value)
    __swig_getmethods__ = {}
    for _s in [Gas]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MQ4, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::MQ4 self, int gasPin) -> MQ4

        Parameters:
            gasPin: int


        MQ4(int gasPin)

        MQ4 constructor

        Parameters:
        -----------

        gasPin:  Analog pin where the sensor is connected 
        """
        this = _pyupm_gas.new_MQ4(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_MQ4
    __del__ = lambda self : None;
    def name(self):
        """
        name(MQ4 self) -> std::string

        Parameters:
            self: upm::MQ4 *


        std::string name()

        Returns the name of the sensor 
        """
        return _pyupm_gas.MQ4_name(self)

MQ4_swigregister = _pyupm_gas.MQ4_swigregister
MQ4_swigregister(MQ4)

class MQ5(Gas):
    """
    API for the MQ5 Gas Sensor.

    ID: mq5

    Name: Grove MQ5 Gas Sensor

    Category: gaseous

    Manufacturer: seeed

    Connection: analog

    Kit: eak  The Grove MQ5 Gas Sensor module is useful for gas leakage
    detection (in home and industry). It can detect LPG, natural gas, town
    gas, and so on. It is highly sensitive and has a detection range of
    300-10,000 ppm.

    C++ includes: mq5.h 
    """
    __swig_setmethods__ = {}
    for _s in [Gas]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MQ5, name, value)
    __swig_getmethods__ = {}
    for _s in [Gas]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MQ5, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::MQ5 self, int gasPin) -> MQ5

        Parameters:
            gasPin: int


        MQ5(int gasPin)

        MQ5 constructor

        Parameters:
        -----------

        gasPin:  Analog pin where the sensor is connected 
        """
        this = _pyupm_gas.new_MQ5(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_MQ5
    __del__ = lambda self : None;
    def name(self):
        """
        name(MQ5 self) -> std::string

        Parameters:
            self: upm::MQ5 *


        std::string name()

        Returns the name of the sensor 
        """
        return _pyupm_gas.MQ5_name(self)

MQ5_swigregister = _pyupm_gas.MQ5_swigregister
MQ5_swigregister(MQ5)

class MQ6(Gas):
    """
    API for the DFRobot MQ6 LPG Gas Sensor.

    ID: mq6

    Name: DFRobot MQ6 LPG Gas Sensor

    Category: gaseous

    Manufacturer: dfrobot

    Connection: analog  The MQ6 Gas Sensor module is useful for detecting
    LPG, iso-butane, propane, and LNG concentrations in the air. It has a
    detection range of 200-10000 ppm.

    For optimum use, it requires calibration after a pre-heat time of at
    least 24 hours. See the datasheet for details.

    C++ includes: mq6.h 
    """
    __swig_setmethods__ = {}
    for _s in [Gas]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MQ6, name, value)
    __swig_getmethods__ = {}
    for _s in [Gas]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MQ6, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::MQ6 self, int gasPin) -> MQ6

        Parameters:
            gasPin: int


        MQ6(int gasPin)

        MQ6 constructor

        Parameters:
        -----------

        gasPin:  Analog pin where the sensor is connected 
        """
        this = _pyupm_gas.new_MQ6(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_MQ6
    __del__ = lambda self : None;
    def name(self):
        """
        name(MQ6 self) -> std::string

        Parameters:
            self: upm::MQ6 *


        std::string name()

        Returns the name of the sensor 
        """
        return _pyupm_gas.MQ6_name(self)

MQ6_swigregister = _pyupm_gas.MQ6_swigregister
MQ6_swigregister(MQ6)

class MQ7(Gas):
    """
    API for the DFRobot MQ7 CO Gas Sensor.

    ID: mq7

    Name: DFRobot MQ7 CO Gas Sensor

    Category: gaseous

    Manufacturer: dfrobot

    Connection: analog  The Grove MQ7 Gas Sensor module is useful for
    detecting Carbon Monoxide (CO) concentrations in the air. It has a
    detection range of 20-2000 ppm.

    For optimum use, it requires calibration after a pre-heat time of 48
    hours. See the datasheet for details.

    C++ includes: mq7.h 
    """
    __swig_setmethods__ = {}
    for _s in [Gas]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MQ7, name, value)
    __swig_getmethods__ = {}
    for _s in [Gas]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MQ7, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::MQ7 self, int gasPin) -> MQ7

        Parameters:
            gasPin: int


        MQ7(int gasPin)

        MQ7 constructor

        Parameters:
        -----------

        gasPin:  Analog pin where the sensor is connected 
        """
        this = _pyupm_gas.new_MQ7(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_MQ7
    __del__ = lambda self : None;
    def name(self):
        """
        name(MQ7 self) -> std::string

        Parameters:
            self: upm::MQ7 *


        std::string name()

        Returns the name of the sensor 
        """
        return _pyupm_gas.MQ7_name(self)

MQ7_swigregister = _pyupm_gas.MQ7_swigregister
MQ7_swigregister(MQ7)

class MQ8(Gas):
    """
    API for the DFRobot MQ8 Hydrogen (H2) Gas Sensor.

    ID: mq8

    Name: DFRobot MQ8 CO Gas Sensor

    Category: gaseous

    Manufacturer: dfrobot

    Connection: analog  The MQ8 Gas Sensor module is useful for detecting
    Hydrogen gas concentrations in the air. It has a detection range of
    100-10000 ppm.

    For optimum use, it requires calibration after a pre-heat time of at
    least 24 hours. See the datasheet for details.

    C++ includes: mq8.h 
    """
    __swig_setmethods__ = {}
    for _s in [Gas]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MQ8, name, value)
    __swig_getmethods__ = {}
    for _s in [Gas]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MQ8, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::MQ8 self, int gasPin) -> MQ8

        Parameters:
            gasPin: int


        MQ8(int gasPin)

        MQ8 constructor

        Parameters:
        -----------

        gasPin:  Analog pin where the sensor is connected 
        """
        this = _pyupm_gas.new_MQ8(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_MQ8
    __del__ = lambda self : None;
    def name(self):
        """
        name(MQ8 self) -> std::string

        Parameters:
            self: upm::MQ8 *


        std::string name()

        Returns the name of the sensor 
        """
        return _pyupm_gas.MQ8_name(self)

MQ8_swigregister = _pyupm_gas.MQ8_swigregister
MQ8_swigregister(MQ8)

class MQ9(Gas):
    """
    API for the MQ9 Gas Sensor.

    ID: mq9

    Name: Grove MQ9 Gas Sensor

    Category: gaseous

    Manufacturer: seeed

    Connection: analog  The Grove MQ9 Gas Sensor module is useful for gas
    leakage detection (in home and industry). It can detect carbon
    monoxide, coal gas, and liquefied gas. Its sensitivity is 10-1,000 ppm
    CO, and 100-10,000 ppm Gas.

    C++ includes: mq9.h 
    """
    __swig_setmethods__ = {}
    for _s in [Gas]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MQ9, name, value)
    __swig_getmethods__ = {}
    for _s in [Gas]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MQ9, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::MQ9 self, int gasPin) -> MQ9

        Parameters:
            gasPin: int


        MQ9(int gasPin)

        MQ9 constructor

        Parameters:
        -----------

        gasPin:  Analog pin where the sensor is connected 
        """
        this = _pyupm_gas.new_MQ9(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_MQ9
    __del__ = lambda self : None;
    def name(self):
        """
        name(MQ9 self) -> std::string

        Parameters:
            self: upm::MQ9 *


        std::string name()

        Returns the name of the sensor 
        """
        return _pyupm_gas.MQ9_name(self)

MQ9_swigregister = _pyupm_gas.MQ9_swigregister
MQ9_swigregister(MQ9)

class TP401(Gas):
    """
    API for the Grove TP401 Air Quality Sensor.

    ID: tp401

    Name: Grove Air Quality Sensor

    Other Names: TP401 Gas Sensor

    Category: gaseous

    Manufacturer: seeed

    Connection: analog

    Kit: hak  The Grove TP401 Air Quality Sensor module is useful for
    monitoring air purity indoors. It can detect CO and a wide range of
    other harmful gases, but, due to a limited detection range, it should
    be used only when qualitative results are needed. Example applications
    are air recirculation, ventilation systems, and refreshing sprayers.
    The sensor is linear and should be roughly sensitive to 0-20 ppm CO
    from 0-4 V. Note: the sensor requires 2-3 minutes to warm up initially
    and 48 hours of operation to stabilize completely.

    C++ includes: tp401.h 
    """
    __swig_setmethods__ = {}
    for _s in [Gas]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TP401, name, value)
    __swig_getmethods__ = {}
    for _s in [Gas]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TP401, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(upm::TP401 self, int gasPin) -> TP401

        Parameters:
            gasPin: int


        TP401(int gasPin)

        TP401 constructor

        Parameters:
        -----------

        gasPin:  Analog pin where the sensor is connected 
        """
        this = _pyupm_gas.new_TP401(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pyupm_gas.delete_TP401
    __del__ = lambda self : None;
    def name(self):
        """
        name(TP401 self) -> std::string

        Parameters:
            self: upm::TP401 *


        std::string name()

        Returns the name of the sensor

        Name of the sensor 
        """
        return _pyupm_gas.TP401_name(self)

    def getPPM(self):
        """
        getPPM(TP401 self) -> float

        Parameters:
            self: upm::TP401 *


        float getPPM()

        Returns one sample in parts per million (ppm) of CO in the air based
        on the following sensor calibration: 0-4 V is roughly 0-20 ppm CO

        New sample converted to ppm CO 
        """
        return _pyupm_gas.TP401_getPPM(self)

TP401_swigregister = _pyupm_gas.TP401_swigregister
TP401_swigregister(TP401)

# This file is compatible with both classic and new-style classes.


